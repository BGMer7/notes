# 云原生

## 云原生概念

**技术的变革，一定是思想先行，**云原生是一种**构建和运行应用程序的方法**，是一套技术体系和方法论。云原生（CloudNative）是一个组合词，Cloud+Native。Cloud表示应用程序位于云中，而不是传统的数据中心；Native表示应用程序从设计之初即考虑到云的环境，原生为云而设计，**在云上以最佳姿势运行**，充分利用和发挥云平台的弹性+分布式优势。

Pivotal公司的Matt Stine于2013年首次提出云原生（CloudNative）的概念；2015年，云原生刚推广时，Matt Stine在《迁移到云原生架构》一书中定义了符合云原生架构的几个特征：12因素、微服务、自敏捷架构、基于API协作、扛脆弱性；到了2017年，Matt Stine在接受InfoQ采访时又改了口风，将云原生架构归纳为模块化、可观察、可部署、可测试、可替换、可处理6特质；而Pivotal最新官网对云原生概括为4个要点：**DevOps+持续交付+微服务+容器**。



2015年云原生计算基金会（CNCF）成立，CNCF掺和进来后，最初把云原生定义为包括：容器化封装+自动化管理+面向微服务；到了2018年，CNCF又更新了云原生的定义，把服务网格(Service Mesh)和声明式API给加了进来。

**总而言之，符合云原生架构的应用程序应该是：采用开源堆栈（K8S+Docker）进行容器化，基于微服务架构提高灵活性和可维护性，借助敏捷方法、DevOps支持持续迭代和运维自动化，利用云平台设施实现弹性伸缩、动态调度、优化资源利用率。**





## 云原生要素

**微服务**：几乎每个云原生的定义都包含微服务，跟微服务相对的是单体应用，微服务有理论基础，那就是康威定律，指导服务怎么切分，很玄乎，凡是能称为理论定律的都简单明白不了，不然就忒没b格，大概意思是组织架构决定产品形态，不知道跟马克思的生产关系影响生产力有无关系。

微服务架构的好处就是按function切了之后，服务解耦，内聚更强，变更更易；另一个划分服务的技巧据说是依据DDD来搞。

**容器化**：Docker是应用最为广泛的容器引擎，在思科谷歌等公司的基础设施中大量使用，是基于LXC技术搞的，容器化为微服务提供实施保障，起到应用隔离作用，K8S是容器编排系统，用于容器管理，容器间的负载均衡，谷歌搞的，Docker和K8S都采用Go编写，都是好东西。

**DevOps**：这是个组合词，Dev+Ops，就是开发和运维合体，不像开发和产品，经常刀刃相见，实际上DevOps应该还包括测试，DevOps是一个敏捷思维，是一个沟通文化，也是组织形式，为云原生提供持续交付能力。

**持续交付**：持续交付是不误时开发，不停机更新，小步快跑，反传统瀑布式开发模型，这要求开发版本和稳定版本并存，其实需要很多流程和工具支撑。



### 云原生的特点

云计算的3层划分，即基础设施即服务(IaaS)、平台即服务(PaaS)、软件即服务(SaaS)为云原生提供了技术基础和方向指引，**真正的云化不仅仅是基础设施和平台的变化，应用也需要做出改变**，摈弃传统的土方法，在架构设计、开发方式、部署维护等各个阶段和方面都基于云的特点，重新设计，从而建设全新的云化的应用，即云原生应用。

1.本地部署的传统应用往往采用c/c++、企业级java编写，而云原生应用则需要用以网络为中心的go、node.js等新兴语言编写。

2.本地部署的传统应用可能需要停机更新，而云原生应用应该始终是最新的，需要支持频繁变更，持续交付，蓝绿部署。

3.本地部署的传统应用无法动态扩展，往往需要冗余资源以抵抗流量高峰，而云原生应用利用云的弹性自动伸缩，通过共享降本增效。

4.本地部署的传统应用对网络资源，比如ip、端口等有依赖，甚至是硬编码，而云原生应用对网络和存储都没有这种限制。

5.本地部署的传统应用通常人肉部署手工运维，而云原生应用这一切都是自动化的。

6.本地部署的传统应用通常依赖系统环境，而云原生应用不会硬连接到任何系统环境，而是依赖抽象的基础架构，从而获得良好移植性。

7.本地部署的传统应用有些是单体(巨石)应用，或者强依赖，而基于微服务架构的云原生应用，纵向划分服务，模块化更合理。



## 云原生原则

软件设计有两个关键目标：**高内聚、低耦合**，围绕这2个核心目标，又提出了单一职责、开闭原则、里氏替换、依赖导致、接口隔离、最少知识等设计原则。



### 高内聚 低耦合

#### 什么是高内聚低耦合

分布式系统的本质就是「分治」和「冗余」。

其中，**分治就是“分解 -> 治理 -> 归并”的三部曲**。「高内聚」、「低耦合」的概念就来源于此。

![preview](https://segmentfault.com/img/bVbnO0s/view?w=1055&h=761)

需要注意的是，当你在做「分解」这个操作的时候，务必要关注每一次的「分解」是否满足一个最重要的条件：**不同分支上的子问题，不能相互依赖，需要各自独立**。

因为一旦包含了依赖关系，子问题和父问题之间就失去了可以被「归并」的意义。

比如，一个「问题Z」被分解成了两个子问题，「子问题A」和「子问题B」。但是，解问题A依赖于问题B的答案，解问题B又依赖于问题A的答案。这不就等于没有分解吗？

> **题外话**：这里的“如何更合理的分解问题”这个思路也可以用到你的生活和工作中的任何问题上。



所以，当你在做「分解」的时候，需要有一些很好的着力点去切入。

这个着力点就是前面提到的「耦合度」和「内聚度」，两者是一个此消彼长的关系。

越符合高内聚低耦合这个标准，程序的维护成本就越低。为什么呢？因为依赖越小，各自的变更对其他关联方的影响就越小。

所以，「高内聚」和「低耦合」是我们应当持续不断追求的目标。

> 耦合度，指的是软件模块之间相互依赖的程度。比如，每次调用方法 A 之后都需要同步调用方法 B，那么此时方法 A 和 B 间的耦合度是高的。
>
> 内聚度，指的是模块内的元素具有的共同点的相似程度。比如，一个类中的多个方法有很多的共同之处，都是做支付相关的处理，那么这个类的内聚度是高的。



#### 如何做到高内聚低耦合

做好高内聚低耦合，思路也很简单：**定职责、做归类、划边界**。

首先，定职责就是定义每一个子系统、每一个模块、甚至每一个class和每一个function的职责。

比如，在子系统或者模块层面可以这样。

![preview](https://segmentfault.com/img/bVbnPji/view?w=720&h=405)

又比如，在class或者function层面可以这样。

![preview](https://segmentfault.com/img/bVbnPjp/view?w=720&h=405)

我想这点大家平时都会有意识的去做。

做好了职责定义后，内聚性就会有很大的提升，同时也提高了代码/程序的复用程度。

至此，我们才谈得上「单一职责（SRP）」这种设计原则的运用。



其次，做归类。梳理不同模块之间的依赖关系。

像上面提到的案例1可以归类为3层：

1. 基础层：商品基础服务、会员基础服务、促销基础服务
2. 聚合层：购物车服务、商品详情服务、登陆服务
3. 接入层：快闪店API、综合商城API

![preview](https://segmentfault.com/img/bVbnPjM/view?w=720&h=405)



案例2也可以归类为3层：

1. 数据访问层：访问会员表数据、访问会员积分表数据、访问会员等级表数据
2. 业务逻辑层：会员登陆逻辑、会员使用积分逻辑、会员升级逻辑
3. 应用层：接收用户输入的账户密码、接收用户输入的使用积分数、接收用户的付款信息

![preview](https://segmentfault.com/img/bVbnPjP/view?w=720&h=405)

#### 最佳实践

很多时候不同的模块或者子系统会被分配到不同的小组中负责，所以z哥再分享几个最佳实践给你。它可以让系统之间的沟通更稳定。

首先是：**模块对外暴露的接口部分，数据类型的选择上尽量做到宽进严出**。比如，使用long代替byte之类的数据类型；使用弱类型代替强类型等等。

```cpp
//使用long代替byte之类的数据类型。

void Add(long param1, long param2){
    if(param1 <1000 && param2 < 1000){  //先接收进来，到里面再做逻辑校验。
        //do something...
    }
    else{
        //do something...
    }
}
```

其次是：**写操作接口，接收参数尽可能少；读操作接口，返回参数尽可能多**。

其次是：**写操作接口，接收参数尽可能少；读操作接口，返回参数尽可能多**。

为什么呢？因为很多时候，写操作的背后会存在一个潜在预期，是「准确」。

准确度和可信度有着很大的联系，只有更多的逻辑处理在自己掌控范围内进行才能越具备「可信度」（当然是职责范围内的逻辑，而不是让商品服务去计算促销的逻辑）。反之，上游系统一个bug就会牵连到你的系统中。

而读操作背后的潜在预期是：「满足」。你得提供给我满足我当前需要的数据，否则我的工作无法开展。

但是呢，在不同时期，客户端所需要的数据可能会发生变化，你无法预测。所以呢，不要吝啬，返回参数尽可能多，用哪些，用不用是客户端的事。

还可以做的更好的一些，就是，在可以满足的基础上支持按需获取。客户端需要返回哪些字段自己通过参数传过来，如此一来还能避免浪费资源做无用的数据传输。

> **题外话**：对外露出的接口设计，可以使用http + json 这种跨平台 + 弱类型的技术组合，可具备更好的灵活性。



实际上，一个程序大多数情况下，在某些时刻是客户端，又在某些时刻是服务端。站在一个完整程序的角度来提炼参数设计的思路就是：**“吃”的要少，“产出”的要多**。

> 题外话：有一些设计原则可以扩展阅读一下。
>
> 单一职责原则SRP(Single Responsibility Principle)
> 开放封闭原则OCP(Open－Close Principle)
> 里式替换原则LSP(the Liskov Substitution Principle LSP)
> 依赖倒置原则DIP(the Dependency Inversion Principle DIP)
> 接口分离原则ISP(the Interface Segregation Principle ISP)