# NoSQL

[redis面试问题（一）_笔经面经_牛客网 (nowcoder.com)](https://www.nowcoder.com/discuss/92610)

[Redis面试题面经整理+解析 - CryFace - 博客园 (cnblogs.com)](https://www.cnblogs.com/CryFace/p/13498188.html)

[Redis 面经_Geffin的博客-CSDN博客_redis 面经](https://blog.csdn.net/Geffin/article/details/103880237)

[Redis 面经_Geffin的博客-CSDN博客_redis 面经](https://blog.csdn.net/Geffin/article/details/103880237)

[Redis 面经整理 - 知乎 (zhihu.com)](https://zhuanlan.zhihu.com/p/347148818)

### 什么是redis？

在Web应用发展的初期，那时关系型数据库受到了较为广泛的关注和应用，原因是因为那时候Web站点基本上访问和并发不高、交互也较少。而在后来，随着访问量的提升，使用关系型数据库的Web站点多多少少都开始在性能上出现了一些瓶颈，而瓶颈的源头一般是在磁盘的I/O上。而随着互联网技术的进一步发展，各种类型的应用层出不穷，这导致在当今云计算、大数据盛行的时代，对性能有了更多的需求，主要体现在以下四个方面：

1. 低延迟的读写速度：应用快速地反应能极大地提升用户的满意度
2. 支撑海量的数据和流量：对于搜索这样大型应用而言，需要利用PB级别的数据和能应对百万级的流量
3. 大规模集群的管理：系统管理员希望分布式应用能更简单的部署和管理
4. 庞大运营成本的考量：IT部门希望在硬件成本、软件成本和人力成本能够有大幅度地降低

为了克服这一问题，NoSQL应运而生，它同时具备了高性能、可扩展性强、高可用等优点，受到广泛开发人员和仓库管理人员的青睐。

Redis（全称：Remote Dictionary Server 远程字典服务）是一个开源的使用ANSI C语言编写、支持网络、可基于内存亦可持久化的日志型、Key-Value数据库，遵守BSD协议。是一个非关系型数据库（NoSQL）。



### Redis为什么快？

1. 完全基于内存，绝大多数的请求是纯粹的内存中的操作，非常快速
2. 数据结构简单，对数据操作也很简单
3. 采用**单线程**，避免了由于上下文的切换和竞争条件，不存在多线程阻塞切换而消耗CPU资源，也不用考虑各种加锁的问题，不会出现死锁而发生性能消耗
4. **使用多路复用模型，非阻塞IO**



### 什么是Memcached

Memcached是一个自由开源的，高性能，分布式内存对象缓存系统。

Memcached是一种基于内存的key-value存储，用来存储小块的任意数据（字符串、对象）。这些数据可以是数据库调用、API调用或者是页面渲染的结果。



### Memcached和Redis的不同

**可靠性（数据持久化）**：Memcached不支持数据持久化，是纯粹的内存存储；Redis支持数据持久化，大约最长每隔2s就会磁盘中写入一次数据，提供可选的可调数据持久性，用于在计划关闭或意外故障后引导缓存。虽然我们倾向于将缓存中的数据视为易失性和瞬态，但将持久化数据保存到磁盘在缓存方案中非常有价值。

**支持的数据结构**：Memcached只支持string类型，但是redis支持string，list，set，sorted set，hash五种数据结构。

存储数据大小：Memcached的key只支持250个字节，redis支持2GB。Memcached的value只支持1MB，redis支持1GB。

线程：Memcached使用多线程，主线程监听，多个worker子线程同时读写，可能会出现锁冲突。redis是单线程的，虽然不用考虑加锁，减少了对于插入修改等写操作的时间，但是无法利用多核提升整体的吞吐量，只能通过多开redis来解决。

存储方式：Memcached将变量存储在内存中，直接从服务器的内存中读取数据，而不是访问数据库。redis可以看成一个驻留在内存中的数据库，从数据库执行读取和写入。

执行速度与性能：Memcached 非常适合处理高流量网站。它可以一次读取许多信息，并在很长的响应时间内返回。redis不太适合用于读取时的高流量，也不能处理繁重的写入。



### redis相比其他数据库的优势

1. 性能极高：redis的读取速度是110000/s，写入的速度是81000/s。
2. 丰富的数据类型：redis支持二进制案例的string，list，hash，set，sorted set。
3. 事务：redis的所有操作都是原子操作，要么成功要么不执行。多个操作也支持事务，但是不支持原子性，即失败的不会影响其他的成功的操作。通过Multi和exec命令包装起来。
4. 丰富的特性 – 速度快；简单稳定； 支持多种数据结构；支持多种编程语言；功能丰富；持久化；主从复制；高可用和分布式。



### redis的局限性

1. 数据库的容量受到内存大小的限制，不能用作海量数据的高性能读写，因此redis主要是用在较小的数据量的高性能操作和运算上。
2. redis不具备自动容错和恢复功能，当主机和从机都宕机之后都会导致前端的读写失败，需要手动重启或者更改IP映射。
3. 主机宕机，宕机之前有部分数据没有及时同步到从机，切换IP之后还会存在数据不一致的问题，降低了系统的可用性。
4. redis难以支持在线扩容，在集群数量达到上限的时候，扩容很麻烦。为避免这一问题，运维人员在系统上线时必须确保有足够的空间，这对资源造成了很大的浪费。



### redis的事务

redis的事务本质就是一串命令的集合。事务支持一次执行多个命令，一个事务中所有命令都会被序列化。在事务执行过程，会按照顺序串行化执行队列中的命令，其他客户端提交的命令请求不会插入到事务执行命令序列中。redis单个命令保证原子性，一个事务里面多个命令就不保证了，即有成功有失败。

redis的事务分为三个阶段，开始事务，事务入队，执行事务。

redis的事务的监测使用watch，watch类似于乐观锁，如果watch中监测的数值被其他客户端修改，那么使用exec执行事务的时候，事务的队列将不会被执行，同时返回nullmulti-bulk应答以通知调用者事务执行失败。



### redis的数据结构类型和使用场景

1. string

   string是最常使用的数据结构类型，redis的所有数据结构都是以唯一的字符串key作为名称，然后通过这个key值来获取相应的value值。不同类型的数据结构的差异就在于value的值不一样。

   string的一个常见的作用是缓存用户信息。将JSON序列化为字符串之后，然后将字符串缓存放进redis进行缓存，取出数据的时候再反序列化输出。

   Redis的字符串是动态字符串，是可以修改的字符串，内部结构实现上类似于Java的ArrayList，采用预分配冗余空间的方式来减少内存的频繁分配，内部的当前字符串时间分配的空间capacity一般要高于实际字符串长度len。当字符串长度小于1M时，扩容都是加倍现有的空间，如果超过1M，扩容时一次只会多扩1M的空间。需要注意的是字符串最大长度为512M。

2. list

   redis的列表相当于Java语言里面的LinkedList，注意它是链表而不是数组。这意味着list的插入和删除操作非常快，时间复杂度为O(1)，但是索引定位很慢，时间复杂度为O(n)。当list弹出最后一个元素之后，数据结构会被自动删除，内存被回收。

   **redis的list常常用来保存异步队列，将需要延后处理的任务结构体序列化成字符串塞进Redis的列表，另一个线程从这个列表中轮询数据进行处理。**

   redis的底层实现是由quickList实现，而不是简单的linkedList。首先在列表元素较少的情况下会使用一块连续的内存存储，这个结构是ziplist，也即是压缩列表。它将所有的元素都紧挨着一起存储，分配的是一块连续的内存。当数据量比较多的时候才会改为quicklist。因为普通的链表需要的附加指针空间太大，会比较浪费空间，而且会加重内存的碎片化。比如这个列表里存的只是int类型的数据，结构上还需要两个额外的指针prev和next。所以Redis将链表和ziplist结合起来组成了quicklist。也就是多个ziplist使用双向指针串起来使用。这样既满足了快速的插入删除性能，又不会出现太大的空间冗余。

3. hash

   redis的字典相当于HashMap，是一个无序字典。内部实现结构上同Java的HashMap也是一致的，同样的数组+链表二维结构。第一维hash的数组位置碰撞时，就会将碰撞的元素使用链表串接起来。
