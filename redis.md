# Redis

### Redis定义

Redis（全称：Remote Dictionary Server 远程字典服务）是一个开源的使用 ANSI C 语言编写、支持网络、可基于内存亦可持久化的日志型、Key-Value 数据库，并提供多种语言的 API。



### Redis的使用场景

1. 缓存：Redis作为缓存，减轻MySQL的查询压力，提升系统性能；
2. 排序：利用Redis的SortSet（有序集合）实现排序；
3. Session 共享：Session 是保存在服务器的文件中，如果是集群服务，同一个用户过来可能落在不同机器上，这就会导致用户频繁登陆；采用 Redis 保存 Session 后，无论用户落在那台机器上都能够获取到对应的 Session 信息；
4. 计数器/限速器：利用 Redis 中原子性的自增操作，我们可以统计类似用户点赞数、用户访问数等。这类操作如果用 MySQL，频繁的读写会带来相当大的压力；限速器比较典型的使用场景是限制某个用户访问某个 API 的频率，常用的有抢购时，防止用户疯狂点击带来不必要的压力；
5. 好友关系：利用集合的一些命令，比如求交集、并集、差集等。可以方便解决一些共同好友、共同爱好之类的功能；
6. 消息队列：除了 Redis 自身的发布/订阅模式，我们也可以利用 List 来实现一个队列机制，比如：到货通知、邮件发送之类的需求，不需要高可靠，但是会带来非常大的 DB 压力，完全可以用 List 来完成异步解耦；



**Redis 不适合的场景**

数据量太大、数据访问频率非常低的业务都不适合使用 Redis，数据太大会增加成本，访问频率太低，保存在内存中纯属浪费资源。





### Redis的功能

[redis有哪些功能 - java面试站 - 博客园 (cnblogs.com)](https://www.cnblogs.com/javamianshizhan/p/13476071.html#:~:text=redis有哪些功能 1 服务端的Redis 2,持久化（Persistence） 3 哨兵（Sentinel）和复制（Replication） 4 集群（Cluster）)

1. **基于本机内存的缓存**

   为了解决调用API依然需要2秒的问题，经过排查，其主要原因在于使用SQL获取热点新闻的过程中消耗了将近2秒的时间，于是乎，我们又想到了一个简单粗暴的解决方案，**即把SQL查询的结果直接缓存在当前api服务器的内存中（设置缓存有效时间为1分钟）**。后续1分钟内的请求直接读缓存，不再花费2秒去执行SQL了。

   假如这个api每秒接收到的请求时100个，那么一分钟就是6000个，也就是只有前2秒拥挤过来的请求会耗时2秒，后续的58秒中的所有请求都可以做到即使响应，而无需再等2秒的时间。

2. **基于服务端的Redis**

   当应用服务器的内存本身就很有限的时候，直接使用本机内存的方案就显得有些捉襟见肘。此时就会有个新的方案，我们**使用一台专门的服务器，用来运行Redis，这台服务器的内存分配很大，并且只用来运行redis**，这样就解决了应用服务器内存吃紧的问题。

3. **持久化（Persistence）**

   单一服务器仍然具有一定的可能性会出现故障，导致所有的缓存都丢失。虽然可以把Redis服务器重新上线，但是由于内存的数据丢失，造成了缓存雪崩，API服务器和数据库的压力还是一下子就上来了。

   所以这个时候Redis的持久化功能就派上用场了，可以缓解一下缓存雪崩带来的影响。**redis的持久化指的是redis会把内存的中的数据写入到硬盘中，在redis重新启动的时候加载这些数据，从而最大限度的降低缓存丢失带来的影响。**

4. **哨兵（Sentinel）和复制（Replication）**

   如果某一台redis服务器挂了，如何切换，如何保证备份的机器是原始服务器的完整备份呢？这时候就需要Sentinel和Replication出场了。

   **Sentinel可以管理多个Redis服务器，它提供了监控，提醒以及自动的故障转移的功能**；**Replication则是负责让一个Redis服务器可以配备多个备份的服务器。**Redis也是利用这两个功能来保证Redis的高可用的。此外，Sentinel功能则是对Redis的发布和订阅功能的一个利用。

5. **集群（Cluster）**

   单台服务器资源的总是有上限的，CPU资源和IO资源我们可以通过主从复制，进行读写分离，把一部分CPU和IO的压力转移到从服务器上。但是内存资源怎么办，主从模式做到的只是相同数据的备份，并不能横向扩充内存；单台机器的内存也只能进行加大处理，但是总有上限的。所以我们就需要一种解决方案，可以让我们横向扩展。最终的目的既是把每台服务器只负责其中的一部分，让这些所有的服务器构成一个整体，对外界的消费者而言，这一组分布式的服务器就像是一个集中式的服务器一样。







### Redis的五种数据结构

1. **String**

   字符串类型是 Redis 最基础的数据结构，首先键是字符串类型，而且其他几种结构都是在字符串类型基础上构建的。字符串类型实际上可以是字符串：简单的字符串、XML、JSON；数字：整数、浮点数；二进制：图片、音频、视频。

   使用场景：缓存、计数器、共享 Session、限速。

2. **Hash**

   在 Redis中哈希类型是指键本身是一种键值对结构，如 value={{field1,value1},……{fieldN,valueN}}

   使用场景：哈希结构相对于字符串序列化缓存信息更加直观，并且在更新操作上更加便捷。所以常常用于用户信息等管理，但是哈希类型和关系型数据库有所不同，哈希类型是稀疏的，而关系型数据库是完全结构化的，关系型数据库可以做复杂的关系查询，而 Redis 去模拟关系型复杂查询开发困难且维护成本高。

3. **List**

   列表类型是用来储存多个有序的字符串，列表中的每个字符串成为元素，一个列表最多可以储存 2 ^ 32 – 1 个元素，在 Redis 中，可以队列表两端插入和弹出，还可以获取指定范围的元素列表、获取指定索引下的元素等，列表是一种比较灵活的数据结构，它可以充当栈和队列的角色。

4. **Set**

   集合类型也是用来保存多个字符串的元素，但和列表不同的是集合中不允许有重复的元素，并且集合中的元素是无序的，不能通过索引下标获取元素，Redis 除了支持集合内的增删改查，同时还支持多个集合取交集、并集、差集。合理的使用好集合类型，能在实际开发中解决很多实际问题。

   使用场景：如：一个用户对娱乐、体育比较感兴趣，另一个可能对新闻感兴趣，这些兴趣就是标签，有了这些数据就可以得到同一标签的人，以及用户的共同爱好的标签，这些数据对于用户体验以及曾强用户粘度比较重要。

5. **Zset**

   有序集合和集合有着必然的联系，它保留了集合不能有重复成员的特性，但不同得是，有序集合中的元素是可以排序的，但是它和列表的使用索引下标作为排序依据不同的是：它给每个元素设置一个分数，作为排序的依据。

   使用场景：排行榜是有序集合经典的使用场景。例如：视频网站需要对用户上传的文件做排行榜，榜单维护可能是多方面：按照时间、按照播放量、按照获得的赞数等。

   

### Redis的性能

1. Redis基于内存，读取速度要超过在硬盘上持久化的数据结构。
2. 数据结构很简单，读取也很快。
3. Redis是单线程，避免了不必要的上下文切换和竞争条件，也不存在多进程或者多线程导致的切换而消耗 CPU，不用去考虑各种锁的问题，不存在加锁释放锁操作，没有因为可能出现死锁而导致的性能消耗；
4. 使用多路 I/O 复用模型，非阻塞 IO；
5. 使用底层模型不同，它们之间底层实现方式以及与客户端之间通信的应用协议不一样，Redis直接自己构建了VM 机制 ，因为一般的系统调用系统函数的话，会浪费一定的时间去移动和请求；

>多路I/O复用模型是利用 select、poll、epoll 可以同时监察多个流的 I/O 事件的能力，在空闲的时候，会把当前线程阻塞掉，当有一个或多个流有 I/O 事件时，就从阻塞态中唤醒，于是程序就会轮询一遍所有的流（epoll 是只轮询那些真正发出了事件的流），并且只依次顺序的处理就绪的流，这种做法就避免了大量的无用操作。
>
>这里“多路”指的是多个网络连接，“复用”指的是复用同一个线程。采用多路 I/O 复用技术可以让单个线程高效的处理多个连接请求（尽量减少网络 IO 的时间消耗），且 Redis 在内存中操作数据的速度非常快，也就是说内存内的操作不会成为影响Redis性能的瓶颈，主要由以上几点造就了 Redis 具有很高的吞吐量。





### 缓存穿透 | 缓存击穿 | 缓存雪崩

[【高并发】面试官：讲讲什么是缓存穿透？击穿？雪崩？如何解决？_缓存_冰河_InfoQ写作社区](https://xie.infoq.cn/article/39495c2d568aca1d6db5c9c50)

#### 缓存穿透

缓存穿透问题在一定程度上与缓存命中率有关。如果我们的缓存设计的不合理，缓存的命中率非常低，那么，这个缓存就形同虚设，数据访问的绝大部分压力都会集中在后端数据库层面。

如果在请求数据时，在缓存层和数据库层都没有找到符合条件的数据，也就是说，在缓存层和数据库层都没有命中数据，那么，这种情况就叫作缓存穿透。

<img src="https://static001.geekbang.org/infoq/a5/a58ddda2d741fecc2b51129e9a1db458.png" alt="img" style="zoom:67%;" />

造成缓存穿透的主要原因就是：**查询某个 Key 对应的数据，Redis 缓存中没有相应的数据，则直接到数据库中查询。数据库中也不存在要查询的数据，则数据库会返回空，而 Redis 也不会缓存这个空结果。这就造成每次通过这样的 Key 去查询数据都会直接到数据库中查询，Redis 不会缓存空结果。**这就造成了缓存穿透的问题。



**解决缓存穿透的方法**

第一种解决方案：**就是把空对象缓存起来。**当第一次从数据库中查询出来的结果为空时，我们就将这个空对象加载到缓存，并设置合理的过期时间，这样，就能够在一定程度上保障后端数据库的安全。

第二种解决方案：就是使用布隆过滤器，布隆过滤器可以针对大数据量的、有规律的键值进行处理。**一条记录是不是存在，本质上是一个 Bool 值，只需要使用 1bit 就可以存储。**我们可以使用布隆过滤器将这种表示是、否等操作，压缩到一个数据结构中。比如，我们最熟悉的用户性别这种数据，就非常适合使用布隆过滤器来处理。



#### 缓存击穿

[如何防止缓存穿透、缓存击穿、缓存雪崩 - 简书 (jianshu.com)](https://www.jianshu.com/p/62725919db21)

缓存击穿是一个热点的Key，有大并发集中对其进行访问，突然间这个Key失效了，导致大并发全部打在数据库上，导致数据库压力剧增。这种现象就叫做缓存击穿。

> 如果缓存中的数据在某个时刻批量过期，导致大部分用户的请求都会直接落在数据库上，这种现象就叫作缓存击穿。

造成缓存击穿的主要原因就是：我们为缓存中的数据设置了过期时间。如果在某个时刻从数据库获取了大量的数据，并设置了相同的过期时间，这些缓存的数据就会在同一时刻失效，造成缓存击穿问题。

![img](https://static001.geekbang.org/infoq/1f/1f307ba02e1c1c04c73b877e167d58e6.png)



**解决缓存击穿的方法**

**对于比较热点的数据，我们可以在缓存中设置这些数据永不过期**；也可以在访问数据的时候，在缓存中更新这些数据的过期时间；如果是批量入库的缓存项，我们可以为这些缓存项分配比较合理的过期时间，避免同一时刻失效。

还有一种解决方案就是：**使用互斥锁。如果缓存失效的情况，只有拿到锁才可以查询数据库**，降低了在同一时刻打在数据库上的请求，防止数据库打死。当然这样会导致系统的性能变差。



#### 缓存雪崩

请求的不同的数据没有命中缓存但是命中数据库，当大量的请求在极短的时间段内一起请求不同数据的缓存并都未命中（如：大批量的数据缓存到期，热点数据没有预热等），这些请求会继续作用到数据库上，造成DB压力剧增，甚至宕机。

缓存击穿是指并发查询某一条数据，缓存雪崩是指不同数据都过期，查询这些数据时都查不到。



![img](https://static001.geekbang.org/infoq/df/df9de5602fe8cc0f07a4b54a0da99151.png)



**解决缓存雪崩的方法**

解决缓存雪崩问题最常用的一种方案就是保证 Redis 的高可用，将 Redis 缓存部署成高可用集群（必要时候做成异地多活），可以有效的防止缓存雪崩问题的发生。

1. 为了缓解大并发流量，我们也可以使用限流降级的方式防止缓存雪崩。例如，**在缓存失效后，通过加锁或者使用队列来控制读数据库写缓存的线程数量**。具体点就是设置某些 Key 只允许一个线程查询数据和写缓存，其他线程等待。则能够有效的缓解大并发流量对数据库打来的巨大冲击。

2. 另外，我们也可以**通过数据预热的方式将可能大量访问的数据加载到缓存，在即将发生大并发访问的时候，提前手动触发加载不同的数据到缓存中。**

3. 为数据**设置不同的过期时间**，让缓存失效的时间点尽量分散，使用随机数设定过期时间，不至于在同一时刻全部失效。
4. **做二级缓存，或者双缓存策略**：Cache1 为原始缓存，Cache2 为拷贝缓存，Cache1 失效时，可以访问 Cache2，Cache1 缓存失效时间设置为短期，Cache2 设置为长期。



### TBD 缓存和数据库的一致性

理论上来说，如果存在绝对理想的缓存过期时间，我们就能保证缓存中的数据是和数据库中的数据是一致。

因为只要缓存数据过期了，就会被删除。随后读的时候，因为缓存里没有，就可以查数据库的数据，然后将数据库查出来的数据写入到缓存中。除了设置过期时间，我们还需要做更多的措施来尽量避免数据库与缓存处于不一致的情况发生。

但是实际上这种理想情况不存在，因为没有办法预测用户会在什么时候进行写入操作。

因此保持缓存和数据库一致性的关键就在于：新增、更改、删除数据库操作时同步更新 Redis，可以使用事务机制来保证数据的一致性。

一般有如下四种方案：

1. 先更新数据库，后更新缓存
2. 先更新缓存，后更新数据库
3. 先删除缓存，后更新数据库
4. 先更新数据库，后删除缓存

四种方案中，

方案一在并发情况下会出现脏读数据，因为这并不是一个原子操作。有可能出现先更新了两次数据库，之后再更新两次缓存。

第二种方案存在的问题是：如果先更新缓存成功，但是数据库更新失败，则肯定会造成数据不一致。







### Redis持久化的方案

#### RDB

[完全掌握Redis持久化：RDB和AOF-Redis-PHP中文网](https://www.php.cn/redis/492972.html)

持久化的方案就是把内存中的数据写入到磁盘中去，主要是为了防止服务器出现异常之后，在内存中的数据丢失，缓存失效。

Redis提供两种持久化的方案：RDB和AOF。

Redis的默认持久化方案是RDB，RDB就是Redis Datebase的缩写，按照一定的时间将快照保存在硬盘中，对应产生的数据库文件为dump.db。它保存的是某一时刻的数据并不关注过程。**RDB保存redis某一时刻的数据的快照。**RDB持久化可以手动触发，也可以自动触发。

**触发快照的方式**

1. 符合自定义配置的快照规则；
2. 执行save或者bgsave命令；
3. 执行flushall命令；
4. 执行主从复制操作 (第一次)。



**RDB执行备份的方式**

redis会单独创建（fork）一个子进程来进行持久化，会先将数据写入到临时文件中，待持久化过程都结束了，再用这个临时文件替换上次持久化好了的文件。**整个过程中，主进程是不进行任何IO操作的**，这就确保了极高的性能。如果需要进行大规模数据的恢复，且对数据的恢复完整性不是非常敏感，那么RDB方式要比AOF方式更加的高效。RDB的缺点是最后一次持久化的数据可能丢失。



**手动触发**：save和bgsave

1. **`save`**
   执行`save`命令会手动触发RDB持久化，**但是`save`命令会阻塞Redis服务**，直到RDB持久化完成。当Redis服务储存大量数据时，会造成较长时间的阻塞，不建议使用。

2. **`bgsave`**
   执行`bgsave`命令也会手动触发RDB持久化，**和`save`命令不同是：Redis服务一般不会阻塞**。Redis进程会执行fork操作创建子进程，RDB持久化由子进程负责，不会阻塞Redis服务进程。Redis服务的阻塞只发生在fork阶段，一般情况时间很短。

   bgsave的流程如下：

   1、执行`bgsave`命令，Redis进程**先判断当前是否存在正在执行的RDB或AOF子线程**，如果存在就是直接结束。
   2、Redis进程执行fork操作创建子线程，在fork操作的过程中Redis进程会被阻塞。
   3、Redis进程fork完成后，`bgsave`命令就结束了，自此Redis进程不会被阻塞，可以响应其他命令。
   4、子进程根据Redis进程的内存生成快照文件，并替换原有的RDB文件。
   5、同时发送信号给主进程，通知主进程rdb持久化完成，主进程更新相关的统计信息（info Persitence下的rdb_*相关选项）。



**自动触发**

除了执行以上命令手动触发以外，Redis内部可以自动触发RDB持久化。自动触发的RDB持久化都是采用`bgsave`的方式，减少Redis进程的阻塞。

1. 在配置文件中设置了`save`的相关配置，如`sava m n`，它表示在m秒内数据被修改过n次时，自动触发`bgsave`操作。
2. 当从节点做全量复制时，主节点会自动执行`bgsave`操作，并且把生成的RDB文件发送给从节点。
3. 执行`debug reload`命令时，也会自动触发`bgsave`操作。
4. 执行`shutdown`命令时，如果没有开启AOF持久化也会自动触发`bgsave`操作。



**dump.rdb中配置RDB**

**快照周期**：内存快照虽然可以通过技术人员手动执行`SAVE`或`BGSAVE`命令来进行，但生产环境下多数情况都会设置其周期性执行条件。

- **Redis中默认的周期新设置**

```shell
# 周期性执行条件的设置格式为
save <seconds> <changes>
# 默认的设置为：
save 900 1
save 300 10
save 60 10000
# 以下设置方式为关闭RDB快照功能
save ""
```

以上三项默认信息设置代表的意义是：

- 如果900秒内有1条Key信息发生变化，则进行快照；
- 如果300秒内有10条Key信息发生变化，则进行快照；
- 如果60秒内有10000条Key信息发生变化，则进行快照。读者可以按照这个规则，根据自己的实际请求压力进行设置调整。



**在进行快照操作的这段时间，如果发生服务崩溃怎么办？**
很简单，在没有将数据全部写入到磁盘前，这次快照操作都不算成功。如果出现了服务崩溃的情况，将以上一次完整的RDB快照文件作为恢复内存数据的参考。也就是说，在快照操作过程中不能影响上一次的备份数据。Redis服务会在磁盘上创建一个临时文件进行数据操作，待操作成功后才会用这个临时文件替换掉上一次的备份。

**可以每秒做一次快照吗？**
对于快照来说，所谓“连拍”就是指连续地做快照。这样一来，快照的间隔时间变得很短，即使某一时刻发生宕机了，因为上一时刻快照刚执行，丢失的数据也不会太多。但是，这其中的快照间隔时间就很关键了。

针对RDB不适合实时持久化的问题，Redis提供了AOF持久化方式来解决。



#### AOF

AOF（Append Only File）持久化是把每次写命令追加写入日志中，当需要恢复数据时重新执行AOF文件中的命令就可以了。AOF解决了数据持久化的实时性，也是目前主流的Redis持久化方式。

> Redis是“写后”日志，Redis先执行命令，把数据写入内存，然后才记录日志。日志里记录的是Redis收到的每一条命令，这些命令是以文本形式保存。
>
> PS: 大多数的数据库采用的是写前日志（WAL），例如MySQL，通过写前日志和两阶段提交，实现数据和逻辑的一致性。

而AOF日志采用写后日志，即**先写内存，后写日志**。

<img src="https://img.php.cn/upload/article/000/000/067/532282aad9aa59277bd836f3a3f290e0-4.png" alt="在这里插入图片描述" style="zoom: 25%;" />

**为什么采用写后日志？**
Redis要求高性能，采用写后日志有两方面好处：

- **避免额外的检查开销**：Redis 在向 AOF 里面记录日志的时候，并不会先去对这些命令进行语法检查。所以，如果先记日志再执行命令的话，日志中就有可能记录了错误的命令，Redis 在使用日志恢复数据时，就可能会出错。
- 不会阻塞当前的写操作

但这种方式存在潜在风险：

- 如果命令执行完成，写日志之前宕机了，会丢失数据。
- 主线程写磁盘压力大，导致写盘慢，阻塞后续操作。



**AOF的实现**

AOF日志记录Redis的每个写命令，步骤分为：命令追加（append）、文件写入（write）和文件同步（sync）。

- **命令追加** 当AOF持久化功能打开了，服务器在执行完一个写命令之后，会以协议格式将被执行的写命令追加到服务器的 aof_buf 缓冲区。
- **文件写入和同步** 关于何时将 aof_buf 缓冲区的内容写入AOF文件中，Redis提供了三种写回策略：

- <img src="https://img.php.cn/upload/article/000/000/067/66727a89e41a7e9789eb52006d878576-5.png" alt="在这里插入图片描述" style="zoom:33%;" />
- Always，同步写回：每个写命令执行完，立马同步地将日志写回磁盘；
- Everysec，每秒写回：每个写命令执行完，只是先把日志写到AOF文件的内存缓冲区，每隔一秒把缓冲区中的内容写入磁盘；
- No，操作系统控制的写回：每个写命令执行完，只是先把日志写到AOF文件的内存缓冲区，由操作系统决定何时将缓冲区内容写回磁盘。

**redis.conf中配置AOF**

默认情况下，Redis是没有开启AOF的，可以通过配置redis.conf文件来开启AOF持久化，关于AOF的配置如下：

```shell
# appendonly参数开启AOF持久化
appendonly no

# AOF持久化的文件名，默认是appendonly.aof
appendfilename "appendonly.aof"

# AOF文件的保存位置和RDB文件的位置相同，都是通过dir参数设置的
dir ./

# 同步策略
# appendfsync always
appendfsync everysec
# appendfsync no

# aof重写期间是否同步
no-appendfsync-on-rewrite no

# 重写触发配置
auto-aof-rewrite-percentage 100
auto-aof-rewrite-min-size 64mb

# 加载aof出错如何处理
aof-load-truncated yes

# 文件重写策略
aof-rewrite-incremental-fsync yes
```



**AOF重写**

> AOF会记录每个写命令到AOF文件，随着时间越来越长，AOF文件会变得越来越大。如果不加以控制，会对Redis服务器，甚至对操作系统造成影响，而且AOF文件越大，数据恢复也越慢。为了解决AOF文件体积膨胀的问题，Redis提供AOF文件重写机制来对AOF文件进行“瘦身”。

<img src="https://img.php.cn/upload/article/000/000/067/66727a89e41a7e9789eb52006d878576-6.png" alt="在这里插入图片描述" style="zoom:50%;" />

***AOF重写会阻塞吗？***
AOF重写过程是由后台进程bgrewriteaof来完成的。主线程fork出后台的bgrewriteaof子进程，fork会把主线程的内存拷贝一份给bgrewriteaof子进程，这里面就包含了数据库的最新数据。然后，bgrewriteaof子进程就可以在不影响主线程的情况下，逐一把拷贝的数据写成操作，记入重写日志。所以aof在重写时，**在fork进程时是会阻塞住主线程的**。

***AOF日志何时会重写？***
有两个配置项控制AOF重写的触发：
**auto-aof-rewrite-min-size**：**表示运行AOF重写时文件的最小大小，默认为64MB**。
**auto-aof-rewrite-percentage**:这个值的计算方式是，当前aof文件大小和上一次重写后aof文件大小的差值，再除以上一次重写后aof文件大小。也就是当前aof文件比上一次重写后aof文件的增量大小，和上一次重写后aof文件大小的比值。

***重写日志时，有新数据写入咋整？***
重写过程总结为：“一个拷贝，两处日志”。在fork出子进程时的拷贝，以及在重写时，如果有新数据写入，主线程就会将命令记录到两个aof日志内存缓冲区中。如果AOF写回策略配置的是always，则直接将命令写回旧的日志文件，并且保存一份命令至AOF重写缓冲区，这些操作对新的日志文件是不存在影响的。（旧的日志文件：主线程使用的日志文件，新的日志文件：bgrewriteaof进程使用的日志文件）

而在bgrewriteaof子进程完成日志文件的重写操作后，会提示主线程已经完成重写操作，主线程会将AOF重写缓冲中的命令追加到新的日志文件后面。这时候在高并发的情况下，AOF重写缓冲区积累可能会很大，这样就会造成阻塞，Redis后来通过Linux管道技术让aof重写期间就能同时进行回放，这样aof重写结束后只需回放少量剩余的数据即可。最后通过修改文件名的方式，保证文件切换的原子性。

在AOF重写日志期间发生宕机的话，因为日志文件还没切换，所以恢复数据时，用的还是旧的日志文件。



#### RDB和AOF混合方式（4.0版本)

> **Redis 4.0 中提出了一个混合使用 AOF 日志和内存快照的方法。简单来说，内存快照以一定的频率执行，在两次快照之间，使用 AOF 日志记录这期间的所有命令操作。**

这样一来，快照不用很频繁地执行，这就避免了频繁 fork 对主线程的影响。而且，AOF 日志也只用记录两次快照间的操作，也就是说，不需要记录所有操作了，因此，就不会出现文件过大的情况了，也可以避免重写开销。



#### 从持久化中恢复数据

> 数据的备份、持久化做完了，我们如何从这些持久化文件中恢复数据呢？如果一台服务器上有既有RDB文件，又有AOF文件，该加载谁呢？

- redis重启时判断是否开启aof，如果开启了aof，那么就优先加载aof文件；
- 如果aof存在，那么就去加载aof文件，加载成功的话redis重启成功，如果aof文件加载失败，那么会打印日志表示启动失败，此时可以去修复aof文件后重新启动；
- 若aof文件不存在，那么redis就会转而去加载rdb文件，如果rdb文件不存在，redis直接启动成功；
- 如果rdb文件存在就会去加载rdb文件恢复数据，如加载失败则打印日志提示启动失败，如加载成功，那么redis重启成功，且使用rdb文件恢复数据；

***那么为什么会优先加载AOF呢？因为AOF保存的数据更完整，通过上面的分析我们知道AOF基本上最多损失1s的数据。***



### Redis的内存淘汰策略

1. volatile-lru：从已设置过期时间的数据集（server. db[i]. expires）中挑选最近最少使用的数据淘汰；
2. volatile-ttl：从已设置过期时间的数据集（server. db[i]. expires）中挑选将要过期的数据淘汰。
3. volatile-random：从已设置过期时间的数据集（server. db[i]. expires）中任意选择数据淘汰。
4. allkeys-lru：从数据集（server. db[i]. dict）中挑选最近最少使用的数据淘汰。
5. allkeys-random：从数据集（server. db[i]. dict）中任意选择数据淘汰。
6. no-enviction（驱逐）：禁止驱逐数据。



### Redis的三种过期删除策略

- 定时过期：每个设置过期时间的key都需要创建一个定时器，到过期时间就会立即清除。该策略可以立即清除过期的数据，对内存很友好；**但是会占用大量的CPU资源去处理过期的数据**，从而影响缓存的响应时间和吞吐量。
- 惰性过期：只有当访问一个key时，才会判断该key是否已过期，过期则清除。该策略**可以最大化地节省CPU资源，却对内存非常不友好**。极端情况可能出现大量的过期key没有再次被访问，从而不会被清除，占用大量内存。
- 定期清除：每隔一定的时间，会扫描一定数量的数据库的expires字典中一定数量的key，并清除其中已过期的key。该策略是前两者的一个折中方案。通过调整定时扫描的时间间隔和每次扫描的限定耗时，可以在不同情况下使得CPU和内存资源达到最优的平衡效果。(expires字典会保存所有设置了过期时间的key的过期时间数据，其中，key是指向键空间中的某个键的指针，value是该键的毫秒精度的UNIX时间戳表示的过期时间。键空间是指该Redis集群中保存的所有键。)

Redis中同时使用了惰性过期和定期过期两种过期策略。



### TBD　Redis线程模型









[SpringBoot整合Mysql、Redis_路上的追梦人的博客-CSDN博客_springboot配置mysql和redis](https://blog.csdn.net/Jiangtagong/article/details/122960915)