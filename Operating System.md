# Operating System Interview

### 操作系统的分类

批操作系统、分时操作系统、实时操作系统



### 内核态和用户态

为了避免操作系统和关键数据被用户修改，将处理器的执行状态分为内核态和用户态。内核态又称为管态和核心态。

内核态是OS管理程序时所处的状态，能够执行包含特权在内的一切指令。能够访问系统内所有的存储空间。

用户态是用户程序执行时所处的状态，不能执行特权指令，只能访问指定的用户地址空间。

操作系统具有硬件的访问权，可以执行机器能够执行的任何指令。软件的其余部分运行在用户态之下。

用户接口程序(shell或者GUI)处于用户态中，并且位于用户态的最底层，允许用户运行其他的程序，例如浏览器，播放器。



### 内核空间和用户空间

现代现在操作系统都是采用虚拟存储器，那么对32位操作系统而言，它的寻址空间（虚拟存储空间）为4G（2的32次方）。操作系统的核心是内核，独立于普通的应用程序，可以访问受保护的内存空间，也有访问底层硬件设备的所有权限。为了保证用户进程不能直接操作内核（kernel），保证内核的安全，操心系统将虚拟空间划分为两部分，一部分为内核空间，一部分为用户空间。针对Linux操作系统而言，将最高的1G字节（从虚拟地址0xC0000000到0xFFFFFFFF），供内核使用，称为内核空间，而将较低的3G字节（从虚拟地址0x00000000到0xBFFFFFFF），供各个进程使用，称为用户空间。



### 如何切换用户态和内核态

处理器从用户态切换到内核态有三种方法：系统调用、异常、外部中断。

1. 系统调用是操作系统的最小功能单位，是操作系统提供的用户接口，系统调用本身是一种软中断。
2. 异常，也叫做内部中断，是由于内部故障影响的，比如文件损坏、缺页故障。
3. 外部中断，当外围设备完成用户请求的操作后，向CPU发出相应的中断信号，这时CPU会暂停执行下一条即将要执行的指令转而去执行与中断信号对应的处理程序，如果先前执行的指令是用户态下的程序，那么这个转换的过程自然也就发生了由用户态到内核态的切换。比如硬盘读写操作完成，系统会切换到硬盘读写的中断处理程序中执行后续操作等。



### 并发和并行

并发：时间上同时执行多条指令。例如单核CPU上的多任务，并发并不能提升计算机的性能，只能提升CPU的效率。

并行：时刻上同时执行多条指令。例如多核CPU，在两个CPU上分别执行两个程序，互不影响，多核可以提升计算机的性能。



### 分层次内存

| 内存类型       | 常见容量 | 访问时间 |
| -------------- | -------- | -------- |
| 寄存器register | <1KB     | 1ns      |
| 高速缓存cache  | 4MB      | 2ns      |
| 主存memory     | GB       | 10ns     |
| 磁盘disk       | GB/TB    | 10ms     |

理想状况下，内存应该非常快，最好要和CPU同样的速度，容量足够大，成本非常低，但是实际上无法同时满足。

寄存器和CPU采用同样的材质制作，所以速度和CPU几乎一样快。

Cache多数由硬件控制，使用频率越高，离CPU越近。当应用程序需要从内存中读取关键词的时候，首先从cache中查询是否有存储，如果有的话就是缓存命中cache hit。缓存中如果没有命中的话就需要从内存中提取，会消耗大量时间。现代CPU一般设计两种缓存，第一级缓存是L1 cache位于CPU内部，用来将已经解码的指令调入CPU的执行引擎，访问没有任何延迟；第二级缓存存放那些频繁使用的关键词，一般容量为MB，访问L2 cache有1-2个时钟周期的延迟。

时钟周期，定义为时钟频率的倒数。时钟周期是计算机中最基本的、最小的时间单位。在一个时钟周期内，CPU仅完成一个最基本的动作。时钟周期是一个时间的量。

在任何缓存系统中都存在以下的问题：

1. 什么时候把新的内容放进缓存中
2. 把新的内容应该放在缓存的哪一行
3. 需要空闲空间时，需要移除哪些缓存内容
4. 应该把移除的内容放到何处



### 虚拟内存

虚拟内存可以让程序拥有超过系统实际物理内存大小的可用内存空间。实现方法是，将程序放在磁盘上，将主存的一部分作为缓存，用来保存最频繁使用的那一部分程序，这种机制需要快速映射内存地址，用来将程序生成的地址转换为有关字节在RAM中的物理地址。这种映射由存储器管理单元MMU实现。

缓存和MMU的出现对于系统的实现有很重要的影响，在多道程序中，从一个程序切换到另一个程序的机制称为上下文切换，对于来自缓存中的资源进行修改并且将其写回磁盘是很有必要的。



### 虚拟内存的作用

1. 虚拟内存作为缓存。

   将主存视为一个存储在磁盘上的地址空间的高速缓存，在主存中只保存活动区域，并根据需要在磁盘和主存之间来回传送数据

2. 虚拟内存作为内存管理。

   为每个进程提供了一致的地址空间，简化内存管理

3. 虚拟内存作为内存保护。

   保护了每个进程的地址空间不被其他进程破坏



### 虚拟地址

[程序的地址空间_audience_fzn的博客-CSDN博客](https://blog.csdn.net/audience_fzn/article/details/81561763)

最早的时候，计算机还没有虚拟机制，程序指令所访问的内存地址就是物理内存地址，所以就要将所有程序都加载到内存中，但是我们实际的物理内存只有4G。所以就会出现一些问题：

- 当多个程序需要运行时，必须保证这些程序用到的内存总量要小于计算机实际的物理内存的大小。

- 内存使用效率低，内存空间不足，就需要将其他程序展示拷贝到硬盘当中，然后将新的程序装入内存。然而由于大量的数据装入装出，内存的使用效率会非常低

- 进程地址空间不隔离，由于程序是直接访问物理内存的，所以每一个进程都可以修改其他进程的内存数据，设置修改内核地址空间中的数据，所以有些恶意程序可以随意修改别的进程，就会造成一些破坏

- 程序运行的地址不确定；因为内存地址是随机分配的，所以程序运行的地址也是不正确的

设计这样一段程序，先是输出程序的地址，再输出这个进程的PID，再输出这个程序地址中的数值，发现父子进程地址一样，但是数值却不一样，因此可以推断出：地址一样，但是变量不一样，变量绝对不是同一个变量，地址绝对不是同一个地址。

在Linux中这就是虚拟地址，在C/C++运行的程序中看到的地址全部都是虚拟地址，物理地址对于用户屏蔽，由OS统一管理，OS负责将虚拟地址转换为物理地址。



### 分段和分页

**段是信息的逻辑单位，它根据用户的需要划分，因此段对于用户是可见的；**

**页是信息的物理单位，是为了管理主存的方便划分的，对用户是透明的。**

段的大小不固定，有它所完成的功能决定，页的大小是固定的，一般是4k

段向用户提供二维地址空间，页向用户提供的是一维地址空间

段是信息的逻辑单位，便于存储保护和信息的共享，页的保护和共享受到限制。

大部分使用了虚拟内存的系统都会使用一种分页的技术。在没有虚拟内存的计算机上，系统直接将虚拟地址送到内存中线上，读写操作都是用同样地址的物理内存，在使用虚拟内存时候，虚拟地址不会直接发送到内存总线上。

**虚拟地址的空间由固定大小的单元组成，这种固定大小的单元称为Pages。**相对的，物理内存中也有固定大小的物理单元，称为页框。页和页框的大小一样。
虚拟地址到物理地址的映射可以总结如下：虚拟地址被分为虚拟页号（高位部分）和偏移量（地位部分）。例如，对于16位地址和4KB的页面大小，高4位可以指定16虚拟页面中的一页面，而低12位可以确定所选页面中的偏移量。
虚拟页号可以作为页表的索引用。由3页表项可以找到页框号，然后把页框号拼接到偏移量的高位端，以替换掉虚拟页号，形成物理地址。
因此，页表的目的就是把虚拟页映射到页框中，从数学上讲，页表就是一个函数，他的参数是虚拟页号，结果是物理框号。通过这个函数可以把虚拟地址中的虚拟页转换为页框，从而形成物理地址。

页表项的结构是及其相关的。页表项中最重要的字段就是页框号（Page Frame Number），页表到页框最重要的就是把此数值映射过去。
另一个重要的是“在/不在”位，如果这个数值是1，那么代表页表项是有效的可使用的，如果这个字段是0的话，代表该页表项对应的虚拟页面不在内存中，访问该页会引起一个缺页中断。
还有修改位和访问位，修改位在页面重新分配的时候很重要，如果一个页面的修改位是1，即它是脏的，那么需要写入磁盘，如果是未修改过的，那么可以直接丢弃。



### 段页式存储管理

分页系统提高内存的利用率，分段系统反映程序的逻辑结构。将分段和分页结合起来，形成了段页式的管理方式。

在段页式存储中，作业的地址空间首先被分成若干个逻辑分段，每段都有自己的段号，然后再将每段分成若干个大小相等的页，对于主存空间也分成大小相等的页，主存的分配以页为单位。

在段页式存储管理系统中，作业的地址空间首先被分成若干个逻辑分段，每段都有自己的段号，然后再将每段分成若干个大小相等的页。对于主存空间也分成大小相等的页，主存的分配以页为单位。

段页式系统中，作业的地址结构包含三部分的内容：段号、页号、页内位移量

程序员按照分段系统的地址结构将地址分为段号与段内位移量，地址变换机构将段内位移量分解为页号和页内位移量。

为实现段页式存储管理，系统应为每个进程设置一个段表，包括每段的段号，该段的页表始址和页表长度。每个段有自己的页表，记录段中的每一页的页号和存放在主存中的物理块号。

- 逻辑地址=页号+页内地址=p+d;

- 物理地址=块号+页内地址=f+d；



### 常见的页面置换算法

当发生缺页异常的时候，OS会选择一个页面换出，并选择一个页面换入，这种现象叫做页面置换。如果即将被换出的页面在内存中已经做过修改，那么必须要将其写入磁盘中，以使得磁盘副本保持最新状态。如果在内存中没有更改过，那么就直接使用新的页面将这个页面进行覆盖。
因为应用程序访问内存是通过虚拟内存映射到物理内存，当物理内存无法映射到物理地址的时候，就会发生缺页中断。

- LRU(Least Recently Used)

  置换最近一段时间以来，最长时间没有被使用过的页面。根据程序局部性的原理，刚刚被访问过的页面，很有可能马上又要被访问，较长时间没有被访问过的页面，后面可能不需要再访问。

- FIFO
  由操作系统维护一个链表，使用先进先出的数据结构，将最先进入的页放在表头，后进入的页放在表尾，并且在发生缺页异常的时候，会把头部的页移除，并且把新的页添加到表尾。

- 时钟置换算法
  将所有的页面都保存在一个类似钟面的环形链表中，一个表针指向最老的页面。
  当缺页错误出现的时候，算法首先检查表针指向的页面，如果它的R位是0就将这个页面淘汰，如果是1就将R位清除并将表针向前移动一个位置。重复这个过程知道找到了一个R位是0的页面位置。
  时钟置换算法初始化的时候，最终结果会是这样的：一开始所有的位置都是0，表示现在可以插入，所以一圈插满之后，每一个位置里都有数据，并且每一个位置的R位都是1。
  一圈初始化结束之后，再有新的页面要进来，先是发现这个位置的R位已经是1，于是将这个位置的R位改为0，然后指针下移，继续判断，直到出现一个位置是0，将这个位置淘汰，插入新的页面。

- LFU
  缺页的时候置换掉引用次数最少的页面。每次访问页面都会将计数+1，缺页的时候置换掉计数数字最小的页面。但是带来的问题是：前期会频繁调用，但是以后不使用的页面会很难置换掉。




### 进程

进程是操作系统中最重要的抽象概念之一，是资源分配的基本单位，是独立运行的基本单位。
进程的经典定义是，一个执行中的程序的实例，系统中的每个程序都运行在一个进程的上下文中。
上下文是由程序正确运行所需要的状态组成的。这个状态包括存放在内存中的程序代码和数据。它的栈、通用目的寄存器的内容、程序计数器、环境变量、打开文件描述符的集合。
进程一般由以下的部分组成：

1. 进程控制块PCB，是进程存在的唯一标识，PCB中包含进程标识符PID、进程当前状态、程序和数据地址、进程的优先级、CPU现场保护区，占有的资源清单等等。
2. 程序段
3. 数据段

Unix系统查看进程通过Ps命令，windows操作系统通过任务管理器。




### 进程的基本操作

进程的创建主要有几种方式创建：系统初始化（init）、正在运行的进程执行了创建进程的系统调用（fork）、用户请求创建一个新的进程、初始化一个批处理工作。

系统初始化的时候会创建一系列的进程，同用户进行交互并且替用户完成工作的进程称之为前台进程。运行在后台，只有任务来的时候才会被唤醒的进程称之为守护进程。
通过系统调用创建，是一个正在运行的进程发出系统调用来创建一个或者多个新的进程来帮助完成工作。例如如果一个程序需要处理大量的网络上的数据，可以创建一个进程用来抓取网络上的数据，并将数据放入缓冲区，再创建一个进程不断读取缓冲区的数据并且进行处理。在Unix中，仅有一个系统调用来创建一个与调用进程相关的副本。在fork之后，一个父进程和子进程会有相同的内存映像，相同的环境字符串和相同的打开文件。通常，子进程会执行execve或者一个简单的系统调用来改变内存映像并运行一个新的程序。

Unix系统下常见的管理进程的操作符
fork
waitpid
execve
exit
open
close
read
write
lseek
stat
mkdir
rmdir
link
unlink
mount
umount
chdir
kill
time

在Unix和Win系统下，进程创建之后 ，父进程和子进程有各自不同的地址空间。如果其中某个进程在其地址空间中做了修改，那么这个修改将对另一个进程不可见。
在Unix中，子进程的地址空间是父进程的一个拷贝，但是确是在不同的地址空间；不可写的内存区域是共享的。

进程的终止，进程一般有以下几种退出：

- 正常退出（自愿）
  多数进程由于完成工作而终止，当编译器完成了所给定的程序的编译之后，编译器会执行一个系统调用告诉OS已经完成了工作，这个调用在Unix是exit。
- 错误退出（自愿）
  进程发生错误会导致进程终止，当可以编译，但是发现了错误，例如发现文件不存在的时候，编译器就会发出声明并且直接退出，但是对于交互式界面来说，会询问用户系统发生了错误，是需要重试还是退出。
- 严重退出（非自愿）
  由于执行了一条非法指令，或者引用了不存在的内存。在Unix中，进程会通知操作系统，进程再收到中断信号，再退出进程，而不是出现问题的时候直接就退出。被其他进程杀死（非自愿）。



### kill命令





### 进程的状态
进程有三种基本的状态：
运行态，运行抬指的是进程实际在占用CPU时间片运行
就绪态，就绪态指的是可以运行，但是因为其他的进程还在运行而处于的就绪状态
阻塞态，除非某种外部事件发生，否则进程不能运行，指的是目前还不具备运行条件的状态，正在等待某个时间完成的状态

三种状态涉及到了四种状态间的转换：
运行态-阻塞态：运行的进程由于某些原因不能继续执行，例如等待输出而阻塞。
运行态-就绪态：CPU分给这个进程的时间片已经用完，CPU需要去执行别的程序而阻塞这个程序。
就绪态-运行态：CPU给这个进程分配了一个时间片。
阻塞态-就绪态：已经满足了程序继续运行的条件，例如获得了输入。



### 什么是僵尸进程？孤儿进程？
孤儿进程：父进程已经退出，这些子进程都将成为孤儿进程，这些进程将会由一号进程，也就是init进程收养，获取进程的状态。
僵尸进程：父进程采用fork创建了子进程，如果子进程退出，但是父进程没有调用wait或者waitpid监听子进程的状态，那么子进程的状态描述符仍然存在系统中的这些进程是僵尸进程。



### 进程间常见的通信方式

1. 管道通信：

   **管道是一种半双工的通信方式，数据只能单向流动**。Linux下一切都是文件，管道就是一个文件，进程A能看到进程B也能看到，同时进程A往管道里写入数据，然后进程B读取数据即可。管道分为匿名管道和命名管道，匿名管道只能用于有亲缘关系的进程，一般就是父进程和子进程。命名管道可以用于任意的进程。

   管道的特点：**管道不适合频繁通信**，因为他需要写入缓存再等另一个进程读取。如果要实现全双工通信，需要两个管道。生命周期随进程。内置同步和互斥机制。

2. 消息队列：

   消息队列的本质就是一个链表，进程A向队列中写数据，如果写满了就不能再写了。队列中有数据之后进程B就可以开始读取数据，读完了就不能读取了。

3. 共享内存：

   共享内存就是映射一段能被其他进程所访问的内存，这段共享内存由一个进程创建，但多个进程都可以访问。**共享内存是最快的 IPC 方式**(不需要从用户态到内核态的切换)，它是针对其他进程间通信方式运行效率低而专门设计的。信号量一般会和共享内存结合使用，信号量用来同步和互斥加锁。

4. 信号量：

   共享内存没有解决多进程竞争内存的问题，类似于线程的安全问题。信号量的本质就是一个计数器，其实是用来实现一个锁的功能，用来实现进程之间的同步和互斥，防止有某个进程正在使用这段共享资源的时候，还有其他的进程在访问这段资源。

5. 套接字：

   套接字除了可以对于本地的进程之间进行通信之外，还可以对于网络中的其他进程进行通信。



### 进程间的同步和互斥机制

即两个或多个线程同时对一共享数据进行修改，从而影响程序运行的正确性时，这种就被称为竞态条件(race condition)。

禁止一个或多个进程在同一时刻对共享资源（包括共享内存、共享文件等）进行读写。

我们把对共享内存进行访问的程序片段称作临界区域。

如果想要设计一个确保线程并发同时访问共享数据的正确性和高效性。一个解决方案应该包含四个特性：

1. 任何时候两个进程都不能同时处于临界区
2. 不应该对CPU的速度和数量做任何假设
3. 位于临界区之外的进程不得阻碍其他的进程
4. 不能使得任何进程无限等待进入临界区



### 临界资源和临界区

临界资源是指一次仅允许一个进程使用的共享资源。各个进程采取互斥的方式，实现共享的资源。

典型的临界资源有：打印机、磁带机；软件临界资源有：消息队列、变量、数组、缓冲区。

临界区：每个进程中访问临界资源的代码成为临界区，每次只允许一个进程进入临界区，进入后不再允许其他进程进入。



### 信号量Semaphore和互斥量Mutex

一个信号就是一个消息，Linux系统支持30多种不同类型的信号，底层的硬件异常是由内核异常处理程序处理的，正常情况下用户是不可见的。

一个信号量的取值可以是 0 ，或任意正数。0 表示的是不需要任何唤醒，任意的正数表示的就是唤醒次数。

Mutex只需要一个二进制位来表示它，不过一般情况下，通常会用一个int来表示。0 表示解锁，其他所有的值表示加锁，比 1 大的值表示加锁的次数。

- 信号量用于同步，互斥量用于互斥。

  互斥：是指某一资源同时只允许一个访问者对其进行访问，具有唯一性和排它性。但互斥无法限制访问者对资源的访问顺序，即访问是无序的。

  同步：是指在互斥的基础上（大多数情况），通过其它机制实现访问者对资源的有序访问。在大多数情况下，同步已经实现了互斥，特别是所有写入资源的情况必定是互斥的。少数情况是指可以允许多个访问者同时访问资源

- 互斥量只能为0或者1，信号量值可以为非负整数。



### 需要进程调度的时候

1. 当前的进程运行结束
2. 当前运行的进程由于某些原因发生了阻塞
3. 执行完系统调用等系统程序之后放回用户进程
4. 在使用抢占调用的时候，拥有最高优先级的进程就绪的时候
5. 分时系统中，分给当前进程的时间片用尽



### 不能进程调度的时候

1. 中断程序运行的时候
2. 在操作系统的内核程序的临界区内
3. 在其他需要完全屏蔽中断的原子操作过程中



### 进程调度算法

1. 先来先服务调度算法 First Come First Serve

   有利于长作业，不利于短作业，有利于CPU繁忙的作业，而不利于IO繁忙的作业。

2. 短作业优先算法 Shortest Job First 

   从后备队列中选择一个或若干个估计运行时间最短的作业，将它们调入内存运行，将它执行直到运行结束。

   长作业的运行得不到保证，有可能出了一个长作业之外都是短作业，那么长作业将会一直得不到运行。

3. 优先级调度算法

   为了照顾紧迫型作业，使之在进入系统之后获得优先处理。优先级调度算法分为抢占式和非抢占式，非抢占式优先权算法下，进程一旦开始运行就会运行到结束，抢占式调度算法中，即使进程没有运行结束，还在运行过程中，只要出现了优先级更高的进程就会把处理机分配给新的优先级高的进程，适用于对于性能要求较高的批处理和分时系统。

4. 时间片轮转调度算法

   在早期的时间片轮转法中，系统将所有的就绪进程按先来先服务的原则排成一个队列，每次调度时，把CPU 分配给队首进程，并令其执行一个时间片。时间片的大小从几ms 到几百ms。当执行的时间片用完时，由一个计时器发出时钟中断请求，调度程序便据此信号来停止该进程的执行，并将它送往就绪队列的末尾；然后，再把处理机分配给就绪队列中新的队首进程，同时也让它执行一个时间片。这样就可以保证就绪队列中的所有进程在一给定的时间内均能获得一时间片的处理机执行时间。

5. 高响应比优先调度算法

   优先权=（等待时间+要求服务时间）/ 要求服务时间， 等待时间+要求服务时间=响应时间

   Rp=响应时间 / 要求服务时间

   由上式可以看出：
   (1) 如果作业的等待时间相同，则要求服务的时间愈短，其优先权愈高，因而该算法有利于短作业。
   (2) 当要求服务的时间相同时，作业的优先权决定于其等待时间，等待时间愈长，其优先权愈高，因而它实现的是先来先服务。
   (3) 对于长作业，作业的优先级可以随等待时间的增加而提高，当其等待时间足够长时，其优先级便可升到很高，从而也可获得处理机。
   简言之，该算法既照顾了短作业，又考虑了作业到达的先后次序，不会使长作业长期得不到服务。因此，该算法实现了一种较好的折衷。当然，在利用该算法时，每要进行调度之前，都须先做响应比的计算，这会增加系统开销。

6. 多级反馈队列调度算法

   几种调度算法的结合形式多级队列方式。



### 线程

进程仍然存在的一些缺点：
进程不能完全地利用CPU，例如一个进程等待输入，那么这个进程将会阻塞，但是实际上还会有很多工作可以不需要输入就继续做下去，但是

- 多线程之间可以共享同一块地址空间和所有的数据，进程不具备这种能力
- 线程要比进程更加轻量级，线程的状态切换比进程要快很多（这种时间上的差异主要是由于大量的未命中导致的），创建一个线程需要的资源要远远小于一个进程所需要的资源
- 从通信机制上来讲，线程间方便的通信机制。对不同进程来说，它们具有独立的地址空间，要进行数据的传递只能通过进程间通信的方式进行。线程则不然，属于同一个进程的不同线程之间共享同一地址空间，所以一个线程的数据可以被其它线程感知，线程间可以直接读写进程数据段（如全局变量）来进行通信（需要一些同步措施）

线程的三个基本概念：

1. 线程是进程划分的任务，是一个进程内可以调动的实体，是CPU调度的基本单位，用于保障程序的实时性，实现进程内部的并发。
2. 线程是操作系统可识别的最小执行和调度单位。每个线程占用一个虚拟处理器：独自的寄存器组、指令计数器和处理器状态。
3. 每个线程完成不一样的任务，但是属于同一个进程的不同线程之间共享同一个地址空间（同样的动态内存、映射文件、目标代码）、打开的文件队列和其他内核资源。



### 线程和进程的区别与联系

1. **一个线程只能属于一个进程，但是一个进程可以拥有多个线程。线程依赖于进程而存在。**
2. **进程在执行的过程中拥有独立的地址空间，而多个线程共享进程的地址空间。**资源分配给进程之后，所有的线程都共享该进程的所有资源。同一个线程共享常量和代码段、数据段（全局变量和静态变量）、扩展段（堆存储）。但是每个进程都拥有自己独立的栈段，栈段又称为运行时段，用来存储所有的局部变量和全局变量。
3. **进程是资源分配的最小单位，线程是CPU调度的最小单位。**
4. 线程通信和进程通信在于，由于线程采用的是同样的地址空间，因此通信机制变得容易。进程之间通信IPC，线程之间可以直接读写进程数据段（如全局变量）来进行通信。
5. 进程之间不会相互影响，但是一个线程挂掉有可能影响整个进程内的线程全部挂掉。
6. 进程适用于多核多机分布、线程适用于多核。

线程的状态转换和进程的状态转换是类似的。



### 线程之间的同步和互斥机制

线程的同步也是在一些关键点上使得多个线程能够相互等待和互通消息。

互斥量：采用互斥对象机制，只有拥有互斥对象的线程才有访问公共资源的权限。因为互斥对象只有一个，所以可以保证公共资源不会被多个线程同时访问。

信号量：它允许同一时刻多个线程访问同一资源，但是需要控制同一时刻访问此资源的最大线程数量。

信号：通过通知操作的方式来保持多线程同步，还可以方便地实现多线程优先级地比较操作。



### 协程





### 死锁

死锁的定义：多个线程同时阻塞，互相等待资源释放

死锁的原因：系统资源的竞争导致资源不足，以及资源的分配不当。进程在运行过程中，请求和释放资源的顺序不对。

**死锁的四个必要条件：**

1. **互斥条件**：一个资源每次只能被一个进程使用，即在一段时间之内，资源仅被一个进程占用，此时如果有其他的进程也要请求这个资源，那么请求进程只能等待。
2. **请求和保持条件（占有和等待）**：进程至少保持了一个资源，又提出了新的资源请求，而该资源已经被其他进程占有，此时请求进程被阻塞，但是对于自己已经获得的资源保持不放。
3. **不可剥夺条件（不可抢占）**：进程所获得的资源在未使用完毕之前，不能被其他进程强行夺走，即，只能是主动释放，其他的进程没有权限接触自身保持的资源。
4. **循环等待条件（环路等待）**：若干的进程之间形成首尾相接循环等待资源的关系。

以上四个条件是导致死锁的必要条件，只要系统发生死锁，那么这些条件必然成立，如果这四个条件有一个不满足，就不会发生死锁。



### 死锁解开的方法

解决死锁的方法也就是破坏掉产生死锁的四个必要条件之一：

1. 资源一次性分配，这样就不会再有请求了（破坏请求条件）
2. 只要有一个资源得不到分配，也不给这个进程分配其他的资源（破坏占有等待条件）
3. 可抢占资源：即当进程新的资源未得到满足时候，释放已经占有的资源，从而破坏不可抢占的条件。
4. 资源有序分配法：系统给每个资源分配一个序号，每个进程按照编号递增地请求资源，释放则相反，从而破坏环路等待的条件。

除此之外，避免死锁还应该在四步中做到：

1. 预防死锁：通过限制一下条件，破坏死锁产生的条件
2. 避免死锁：在资源分配的过程中，使用某些方法避免系统进入不安全的状态。
3. 检测死锁：允许死锁的发生，发生之后再检测清除。
4. 解除死锁：检测出来之后解除死锁。



### 银行家算法

操作系统相当于是银行家，操作系统管理的资源相当于银行家的资金，进程向操作系统请求分配资源相当于用户向银行家申请贷款。银行家遵循以下的原则：

1. 当一个客户对于资金的需求不超过银行家所拥有的的资金时候就可以接纳这个客户。
2. 客户可以分期贷款，但是贷款的总数也不能超过最大的需求量。
3. 当银行家现有的资金不能满足顾客尚需的贷款数额时，对于顾客的贷款可以推迟支付，但必须要使得客户在有限的时间内获得贷款。
4. 当客户获得了所有的资金之后，必须要在规定的时间之内归还所有的资金。



### 进程之间的同步和线程之间的同步的区别

进程之间地址空间不同，不能感知对方的存在，同步时需要将锁放在**多进程共享**的空间。而线程之间共享同一地址空间，**同步时把锁放在所属的同一进程空间即可**。



### 上下文切换

上下文切换是指CPU从一个进程（线程）切换到另一个进程（线程）。

上下文中的内容：CPU中的寄存器中的内容和程序计数块PCB在此时计算的内容。

上下文切换时做的工作：

1. 保存处理机上下文，包括程序计数器和其他寄存器。
2. 更新PCB信息。
3. 把进程的PCB移入相应的队列，如就绪、在某事件阻塞等队列。
4. 选择另一个进程执行，并更新其PCB。
5. 更新内存管理的数据结构。
6. 恢复处理机上下文。

上下文切换的过程还是会消耗很多资源的



### 进程的阻塞

正在执行的进程，由于有执行的条件不满足，例如请求资源失败、等待某个操作的完成、数据尚未更新，系统将会自动执行阻塞原语(block)，使得自己由运行态进入阻塞态，从而不占用CPU资源。进程的阻塞时主动行为，只有处于运行态的进程(获得CPU的进程)，才可能将自己阻塞。



### I/O

缓存 I/O 又被称作标准 I/O，大多数文件系统的默认 I/O 操作都是缓存 I/O。在 Linux 的缓存 I/O 机制中，**操作系统会将 I/O 的数据缓存在文件系统的页缓存（ page cache ）中，也就是说，数据会先被拷贝到操作系统内核的缓冲区中，然后才会从操作系统内核的缓冲区拷贝到应用程序的地址空间。**
但是数据在传输过程中需要在应用程序地址空间和内核进行多次数据拷贝操作，这些**数据拷贝操作所带来的 CPU 以及内存开销是非常大的。**

Linux详细的IO模式见Linux.md。



### 写时复制

当多个进程需要同时共享同一个资源的时候，那么就会存在写的问题。如果每个进程都不会修改这个资源，那么复制副本是不需要的，因为这个资源对于进程来说都一样，都是独占的。但是如果一个进程要求改自己的那份资源副本，那么就需要复制这个资源，并且把复制的那份提供给进程，不过复制的过程对于进程来说是透明的，这样子进程就可以修改复制之后的资源了，但是其他的进程仍然使用的是没有修改过的资源，这就是写时复制。

写时复制是一种惰性算法，也就是说，如果不修改那就不操作，直到有进程修改再操作，直到必要时候再执行。

在使用虚拟内存的情况下，写时复制（Copy-On-Write）是以页为基础进行的。所以，只要进程不修改它全部的地址空间，那么就不必复制整个地址空间。在fork()调用结束后，父进程和子进程都相信它们有一个自己的地址空间，但实际上它们共享父进程的原始页，接下来这些页又可以被其他的父进程或子进程共享。



### 优先级反转

由于多进程共享资源，具有最高优先权的进程被低优先级进程阻塞，反而使具有中优先级的进程先于高优先级的进程执行，导致系统的崩溃。这就是所谓的优先级反转(Priority Inversion)。其实,优先级反转是在高优级(假设为A)的任务要访问一个被低优先级任务(假设为C)占有的资源时,被阻塞.而此时又有优先级高于占有资源的任务(C)而低于被阻塞的任务(A)的优先级的任务(假设为B)时,于是,占有资源的任务就被挂起(占有的资源仍为它占有),因为占有资源的任务优先级很低,所以,它可能一直被另外的任务挂起.而它占有的资源也就一直不能释放,这样,引起任务A一直没办法执行.而比它优先低的任务却可以执行。

目前解决优先级反转有许多种方法。其中普遍使用的有2种方法：一种被称作优先级继承(priority inheritance)；另一种被称作优先级极限(priority ceilings)。

1. 优先级继承(priority inheritance) 优先级继承是指将低优先级任务的优先级提升到等待它所占有的资源的最高优先级任务的优先级.当高优先级任务由于等待资源而被阻塞时,此时资源的拥有者的优先级将会自动被提升。
2. 优先级天花板(priority ceilings)优先级天花板是指将申请某资源的任务的优先级提升到可能访问该资源的所有任务中最高优先级任务的优先级.(这个优先级称为该资源的优先级天花板)。



















#### OS常用函数与指令实践

###### fork

[简述C语言fork()函数用法：_cuit2016123070的博客-CSDN博客](https://blog.csdn.net/cuit2016123070/article/details/83280125)

[C++通过fork创建子进程实战_实践求真知-CSDN博客_c++ fork子进程](https://blog.csdn.net/chengqiuming/article/details/88925229)

[c/c++ linux 进程 fork wait函数 - 小石王 - 博客园 (cnblogs.com)](https://www.cnblogs.com/xiaoshiwang/p/9808278.html)

[Linux编程基础之进程等待（wait()函数 - 深蓝工作室 - 博客园 (cnblogs.com)](https://www.cnblogs.com/king-77024128/articles/2684317.html)

【精】[C++进程管理（下Fork与Exec使用 ）-coolzsj-ChinaUnix博客](http://blog.chinaunix.net/uid-97185-id-4330346.html)

###### wait

[C++_详解C语1言中的wait()函数和waitpid()函数，C语言wait()函数：结束(中断)进 - phpStudy (xp.cn)](https://www.xp.cn/b.php/76918.html)

[Linux中waitpid()函数的用法_Roland_Sun的专栏-CSDN博客_waitpid函数](https://blog.csdn.net/Roland_Sun/article/details/32084825)

```cpp
#include <sys/types.h> 
#include <sys/wait.h>
pid_t waitpid(pid_t pid,int *status,int options);
```

1. pid_t pid 

   如果在调用waitpid()函数时，当指定等待的子进程已经停止运行或结束了，则waitpid()会立即返回；但是如果子进程还没有停止运行或结束，则调用waitpid()函数的父进程则会被阻塞，暂停运行。

   pid是想要等待的子进程的进程识别码：

   | 参数值 | 说明                                                         |
   | ------ | ------------------------------------------------------------ |
   | pid<-1 | 等待进程组号为pid绝对值的任何子进程。                        |
   | pid=-1 | 等待任何子进程，此时的waitpid()函数就退化成了普通的wait()函数。 |
   | pid=0  | 等待进程组号与目前进程相同的任何子进程，也就是说任何和调用waitpid()函数的进程在同一个进程组的进程。 |
   | pid>0  | 等待进程号为pid的子进程。                                    |

2. int* status

   这个参数将保存子进程的状态信息，有了这个信息父进程就可以了解子进程为什么会退出，是正常退出还是出了什么错误。如果status不是空指针，则状态信息将被写入器指向的位置。当然，如果不关心子进程为什么退出的话，也可以传入空指针。
   Linux提供了一些非常有用的宏来帮助解析这个状态信息，这些宏都定义在sys/wait.h头文件中。主要有以下几个：

   | 宏                  | 说明                                                         |
   | ------------------- | ------------------------------------------------------------ |
   | WIFEXITED(status)   | 如果子进程正常结束，它就返回真；否则返回假。                 |
   | WEXITSTATUS(status) | 如果WIFEXITED(status)为真，则可以用该宏取得子进程exit()返回的结束代码。 |
   | WIFSIGNALED(status) | 如果子进程因为一个未捕获的信号而终止，它就返回真；否则返回假。 |
   | WTERMSIG(status)    | 如果WIFSIGNALED(status)为真，则可以用该宏获得导致子进程终止的信号代码。 |
   | WIFSTOPPED(status)  | 如果当前子进程被暂停了，则返回真；否则返回假。               |
   | WSTOPSIG(status)    | 如果WIFSTOPPED(status)为真，则可以使用该宏获得导致子进程暂停的信号代码。 |

   

3. int options

   参数options提供了一些另外的选项来控制waitpid的行为，如果不想使用的话，可以把这一项设置为0

   主要使用的有以下两个选项：

   | 参数      | 说明                                                         |
   | --------- | ------------------------------------------------------------ |
   | WNOHANG   | 如果pid指定的子进程没有结束，则waitpid()函数立即返回0，而不是阻塞在这个函数上等待；如果结束了，则返回该子进程的进程号。 |
   | WUNTRACED | 如果子进程进入暂停状态，则马上返回。                         |

   这些参数可以用“|”运算符连接起来使用。
   如果waitpid()函数执行成功，则返回子进程的进程号；如果有错误发生，则返回-1，并且将失败的原因存放在errno变量中。
   失败的原因主要有：没有子进程（errno设置为ECHILD），调用被某个信号中断（errno设置为EINTR）或选项参数无效（errno设置为EINVAL）
   如果像这样调用waitpid函数：waitpid(-1, status, 0)，这此时waitpid()函数就完全退化成了wait()函数。




### 线程安全

> Thread safety is a computer programming concept applicable to multi-threaded code. Thread-safe code only manipulates shared data structures in a manner that ensures that all threads behave properly and fulfill their design specifications without unintended interaction. There are various strategies for making thread-safe data structures
> 线程安全是计算机编程多线程编程的一个概念。线程安全的代码只会在某种规范下操作共享数据，并确保其他线程的行为是准确的并保证他们的行为是符合其需求的同时其他线程不会对其有意料之外的操作。实现线程安全的数据结构有多种多样的方式。

线程安全：首先线程安全一定发生在多线程的运行情况下，所有的隐患都来自于多个线程的访问。通俗来说，线程安全就是在多线程的运行环境下，程序还能够按照我们的设计运行。

[C++多线程----线程安全_雪花飞龙的博客-CSDN博客_c++线程安全](https://blog.csdn.net/weixin_43956732/article/details/109751075)

```cpp
#include <iostream>
#include <thread>
#include <time.h>

using namespace std;

long cnt = 0;

void plusCnt()
{
    int i = 10000;
    while (i--)
        ++cnt;
}

int main()
{
    clock_t start = clock();
    thread threads[100];
    for (int i(0); i < 100; ++i)
        threads[i] = thread(plusCnt);

    for (auto &th : threads)
        th.join();

    clock_t finish = clock();
    cout << "期望结果：" << 100 * 10000 << endl;
    cout << "实际结果：" << cnt << endl;
    cout << "duration: " << finish - start << "ms" << endl;
    return 0;
}

期望结果：1000000
实际结果：998444
duration: 5ms
```

可以看出，存在数据丢失问题，其原因是同时访问变量cnt导致，所以，需要采用编程方法，保证每次只能有一个程序访问cnt变量。

采用互斥锁mutex，调用#include<mutex>，其主要类为std::mutex，主要成员函数为：

- **构造函数**

  构造函数，std::mutex不允许拷贝构造，也不允许 move 拷贝，最初产生的 mutex 对象是处于 unlocked 状态的。

- **lock()函数**

  lock()，调用线程将锁住该互斥量。线程调用该函数会发生下面 3 种情况：lock()，调用线程将锁住该互斥量。线程调用该函数会发生下面3种情况：

  (1). 如果该互斥量当前没有被锁住，则调用线程将该互斥量锁住，直到调用 unlock之前，该线程一直拥有该锁。
  (2). 如果当前互斥量被其他线程锁住，则当前的调用线程被阻塞住。
  (3). 如果当前互斥量被当前调用线程锁住，则会产生死锁(deadlock)。

- **unlock()函数**

  unlock()， 解锁，释放对互斥量的所有权。

- **try_lock()函数**

  try_lock()，尝试锁住互斥量，如果互斥量被其他线程占有，则当前线程也不会被阻塞。线程调用该函数也会出现下面 3 种情况：
  (1). 如果当前互斥量没有被其他线程占有，则该线程锁住互斥量，直到该线程调用 unlock 释放互斥量。
  (2). 如果当前互斥量被其他线程锁住，则当前调用线程返回 false，而并不会被阻塞掉。
  (3). 如果当前互斥量被当前调用线程锁住，则会产生死锁(deadlock)。



```cpp
#include <iostream>
#include <thread>
#include <time.h>
#include <mutex> //添加互斥变量头文件

//创建互斥变量锁
std::mutex my_mutex;


//计数全局变量
long cnt = 0;

//计数程序
void counter()
{
	for (int i = 0; i < 100000; ++i)
	{
		//每次计算锁住变量
		my_mutex.lock();
		++cnt;
		my_mutex.unlock();
	}
}


int main(int argc, char* argv[])
{
	//开始计时
	clock_t start = clock();

	//创建线程
	std::thread threads[100];

	//调用记数函数
	for (int i = 0; i != 100; ++i)
		threads[i] = std::thread(counter);

	//等待操作
	for (auto& th : threads)
		th.join();

	clock_t finish = clock();

	std::cout << "期望结果：" << 100 * 100000 << std::endl;
	std::cout << "实际结果:" << cnt << std::endl;
	std::cout << "duration:" << finish - start << "ms" << std::endl;
	
	return 0;
}


期望结果：1000000
实际结果：1000000
duration: 135ms
```



### pipe管道

pipe管道又称为匿名管道，由pipe函数直接创建。

```cpp
#include <unistd.h>
int pipe(int pipefd[2]);
```

调用pipe函数时在内核中开辟一块缓冲区用于通信,它有一个读端，一个写端：**pipefd[0]指向管道的读端，pipefd[1]指向管道的写端**。所以管道在用户程序看起来就像一个打开的文件,通过read(pipefd[0])或者write(pipefd[1])向这个文件读写数据，其实是在读写内核缓冲区。要实现双向数据传输，可以使用两个管道。

默认情况下，这一对文件描述符都是阻塞的。此时，如果我们用read系统调用来读取一个空的管道，则read将被阻塞，知道管道内有数据可读；如果我们用write系统调用往一个满的管道中写数据，则write也将被阻塞，直到管道有足够的空闲空间可用(read读取数据后管道中将清除读走的数据)。当然，用户可自行将 fd[0] 和 fd[1] 设置为非阻塞的。
管道读写中可能出现的四种情况：

1. write关闭，read没有关闭。

   那么就像读文件读到最后的时候，read会返回一个0。

2. write没有关闭，但是也不写数据，read也不关闭。

   此时管道中剩余的数据都被读取之后再次read会被阻塞，直到管道中有数据可读了才重新读取数据并返回。

3. read关闭，write没有关闭。

   此时该进程会收到信号SIGPIPE，通常会导致进程异常终止。

4. read没有关闭，但是也不读数据，write不关闭。

   此时当写端被写满之后再次write会阻塞，直到管道中有空位置了才会写入数据并重新返回。

使用管道有一些缺点：

两个进程只能实现单向通信，因为管道的pipe[0]只能read，pipe[1]只能write。如果想要双向通信的话必须要是使用两个管道。

只能在关系进程之间进行通信，因为从demo可以看到，是通过fork创建的。

```cpp
#include <stdio.h>
#include <iostream>
#include <unistd.h>
#include <stdlib.h>
#include <string.h>
#include <sys/types.h>
#include <sys/wait.h>
int main()
{
    int _pipe[2] = {0, 0};
    int ret = pipe(_pipe); //创建管道
    std::cout << "this is the int pipe returned :" << ret << std::endl;
    std::cout << "_pipe[0] is " << _pipe[0] << ", _pipe[1] is " << _pipe[1] << std::endl;

    if (ret == -1)
    {
        perror("create pipe error");
        return 1;
    }

    pid_t id = fork(); //父进程fork子进程
    std::cout << "father pid is " << getpid() << std::endl; // father process id
    std::cout << "child pid is " << id << std::endl; // child process id
    printf("\n");

    if (id < 0)
    {
        perror("fork error");
        return 2;
    }
    else if (id == 0) //child,写
    {
        printf("child writing\n");
        close(_pipe[0]);
        int count = 5;
        const char *msg = "i am from XATU";
        while (count--)
        {
            write(_pipe[1], msg, strlen(msg));
            sleep(1);
        }
        close(_pipe[1]);
        exit(1);
    }
    else //father,读
    {
        printf("father reading\n");
        close(_pipe[1]);
        char msg[1024];
        int count = 5;
        while (count--)
        {
            ssize_t s = read(_pipe[0], msg, sizeof(msg) - 1);
            if (s > 0)
            {
                msg[s] = '\0';
                printf("client# %s\n", msg);
            }
            else
            {
                perror("read error");
                exit(1);
            }
        }
        if (waitpid(id, 0, NULL) != -1)
        {
            printf("wait success\n");
        }
    }
    return 0;
}
```



### fifo管道

匿名管道只适用于关系进程，命名管道解决了这个问题。FIFO不同于管道之处在于它提供一个路径名与之关联，以FIFO的文件形式存储文件系统中。**命名管道是一个设备文件**，因此即使进程与创建FIFO的进程不存在亲缘关系，只要可以访问该路径，就能够通过FIFO相互通信。

命名管道的创建和读写：mknod或者mkfifo

> int mknod(const char *pathname, mode_t mode, dev_t dev);
>
> int mkfifo(const char *pathname, mode_t mode);

返回值：都是成功返回0，失败返回-1；

path为创建的命名管道的全路径名；

mod为创建的命名管道的模式，指明其存取权限；

dev为设备值，该值取决于文件创建的种类，它只在创建设备文件时才会用到；

mkfifo函数的作用：在文件系统中创建一个文件，该文件用于提供FIFO功能，即命名管道。

命名管道的特点：

**命名管道必须是一个存在于硬盘上的文件，而管道是一个在内存中的文件。所以使用命名管道的时候必须使用open()将其打开。**

```cpp
server:
#include <stdio.h>
#include <stdlib.h>
#include <sys/types.h>
#include <sys/stat.h>
#include <fcntl.h>
void testserver()
{
    int namepipe = mkfifo("myfifo", S_IFIFO | 0666); //创建一个存取权限为0666的命名管道
    if (namepipe == -1)
    {
        perror("mkfifo error");
        exit(1);
    }
    int fd = open("./myfifo", O_RDWR); //打开该命名管道
    if (fd == -1)
    {
        perror("open error");
        exit(2);
    }
    char buf[1024];
    while (1)
    {
        printf("sendto# ");
        fflush(stdout);
        ssize_t s = read(0, buf, sizeof(buf) - 1); //从标准输入获取消息
        if (s > 0)
        {
            buf[s - 1] = '\0'; //过滤掉从标准输入中获取的换行
            if (write(fd, buf, s) == -1)
            { //把该消息写入到命名管道中
                perror("write error");
                exit(3);
            }
        }
    }
    close(fd);
}
int main()
{
    testserver();
    return 0;
}
```

```cpp
client:
#include <stdio.h>
#include <stdlib.h>
#include <sys/types.h>
#include <sys/stat.h>
#include <fcntl.h>
void testclient()
{
    int fd = open("./myfifo", O_RDWR);
    if (fd == -1)
    {
        perror("open error");
        exit(1);
    }
    char buf[1024];
    while (1)
    {
        ssize_t s = read(fd, buf, sizeof(buf) - 1);
        if (s > 0)
        {
            printf("client# %s\n", buf);
        }
        else
        { //读失败或者是读取到字符结尾
            perror("read error");
            exit(2);
        }
    }
    close(fd);
}
int main()
{
    testclient();
    return 0;
}

```

运行结果：

```shell
server:
gatsby@ubuntu:~/Desktop/os$ ./commu_fifo_server 
sendto# hello this is cerver
sendto# hello this is server
sendto# 

client:
gatsby@ubuntu:~/Desktop/os$ ./commu_fifo_client 
client# hello this is cerver
client# hello this is server
```



### 消息队列

[Linux进程间通信——使用消息队列_ljianhui的专栏-CSDN博客_linux 消息队列](https://blog.csdn.net/ljianhui/article/details/10287879)

Linux提供了一系列消息队列的函数接口来让我们方便地使用它来实现进程间的通信。它的用法与其他两个System V PIC机制，即信号量和共享内存相似。

1. msgget()

   用来创建和访问一个消息队列

   ```cpp
   int msgget(key_t, key, int msgflg);
   ```

   返回一个以key命名的消息队列，成功时返回一个非零整数，失败时返回-1。msgflg是一个权限标志，表示消息队列的访问权限，它与文件的访问权限一样。

2. msgsnd()

   用来将消息添加到消息队列中去，原型为：

   ```cpp
   int msgsnd(int msgid, const void* msg_ptr, size_t msg_sz, int msgflg);
   ```

   msgid是由msgget函数返回的消息队列标识符。msg_ptr是一个指向准备发送消息的指针，但是消息的数据结构却有一定的要求，指针msg_ptr所指向的消息结构一定要是以一个长整型成员变量开始的结构体，接收函数将用这个成员来确定消息的类型。

   msg_sz是msg_ptr指向的消息的长度，注意是消息的长度，而不是整个结构体的长度，也就是说msg_sz是不包括长整型消息类型成员变量的长度。

   msgflg用于控制当前消息队列满或队列消息到达系统范围的限制时将要发生的事情。

   如果调用成功，消息数据的一分副本将被放到消息队列中，并返回0，失败时返回-1。

3. msgrcv()

   用来从一个消息队列获取消息。

   ````cpp
   int msgrcv(int msgid, void *msg_ptr, size_t msg_sz, long int msgtype, int msgflg);
   ````

   调用成功时，该函数返回放到接收缓存区中的字节数，消息被复制到由msg_ptr指向的用户分配的缓存区中，然后删除消息队列中的对应消息。失败时返回-1。

4. msgctl()

   ```cpp
   int msgctl(int msgid, int command, struct msgid_ds *buf);
   ```

```cpp
// commu_msg_send.cpp
#include <unistd.h>
#include <stdlib.h>
#include <stdio.h>
#include <string.h>
#include <sys/msg.h>
#include <errno.h>
 
#define MAX_TEXT 512
struct msg_st
{
	long int msg_type;
	char text[MAX_TEXT];
};
 
int main()
{
	int running = 1;
	struct msg_st data;
	char buffer[BUFSIZ];
	int msgid = -1;
 
	//建立消息队列
	msgid = msgget((key_t)1234, 0666 | IPC_CREAT);
	if(msgid == -1)
	{
		fprintf(stderr, "msgget failed with error: %d\n", errno);
		exit(EXIT_FAILURE);
	}
 
	//向消息队列中写消息，直到写入end
	while(running)
	{
		//输入数据
		printf("Enter some text: ");
		fgets(buffer, BUFSIZ, stdin);
		data.msg_type = 1;    //注意2
		strcpy(data.text, buffer);
		//向队列发送数据
		if(msgsnd(msgid, (void*)&data, MAX_TEXT, 0) == -1)
		{
			fprintf(stderr, "msgsnd failed\n");
			exit(EXIT_FAILURE);
		}
		//输入end结束输入
		if(strncmp(buffer, "end", 3) == 0)
			running = 0;
		sleep(1);
	}
	exit(EXIT_SUCCESS);
}

// commu_msg_recv.cpp
#include <unistd.h>
#include <stdlib.h>
#include <stdio.h>
#include <string.h>
#include <errno.h>
#include <sys/msg.h>
 
struct msg_st
{
	long int msg_type;
	char text[BUFSIZ];
};
 
int main()
{
	int running = 1;
	int msgid = -1;
	struct msg_st data;
	long int msgtype = 0; //注意1
 
	//建立消息队列
	msgid = msgget((key_t)1234, 0666 | IPC_CREAT);
	if(msgid == -1)
	{
		fprintf(stderr, "msgget failed with error: %d\n", errno);
		exit(EXIT_FAILURE);
	}
	//从队列中获取消息，直到遇到end消息为止
	while(running)
	{
		if(msgrcv(msgid, (void*)&data, BUFSIZ, msgtype, 0) == -1)
		{
			fprintf(stderr, "msgrcv failed with errno: %d\n", errno);
			exit(EXIT_FAILURE);
		}
		printf("You wrote: %s\n",data.text);
		//遇到end结束
		if(strncmp(data.text, "end", 3) == 0)
			running = 0;
	}
	//删除消息队列
	if(msgctl(msgid, IPC_RMID, 0) == -1)
	{
		fprintf(stderr, "msgctl(IPC_RMID) failed\n");
		exit(EXIT_FAILURE);
	}
	exit(EXIT_SUCCESS);
}

```

运行结果：

```shell
gatsby@ubuntu:~/Desktop/os$ ./commu_msg_send 
Enter some text: this is a msg
Enter some text: pls answer
Enter some text: what if end
Enter some text: only end
Enter some text:end

gatsby@ubuntu:~/Desktop/os$ ./commu_msg_recv 
You wrote: this is a msg
You wrote: pls answer
You wrote: what if end
You wrote: only end
You wrote: end

// 只有当输入为end的时候会停止
```





### 信号量













### 锁









### 共享内存





​		












#####  参考文章

[我和面试官之间关于操作系统的一场对弈！写了很久，希望对你有帮助！ - JavaGuide - 博客园 (cnblogs.com)](https://www.cnblogs.com/javaguide/p/operating-system.html)

[操作系统八股文背诵版 - 知乎 (zhihu.com)](https://zhuanlan.zhihu.com/p/373966882)

[操作系统面试---进程调度方法_程序员面试之道的博客-CSDN博客](https://blog.csdn.net/weixin_41563161/article/details/104105468)

[百度面试（进程调度、调度算法）_yutianxin123的专栏-CSDN博客](https://blog.csdn.net/yutianxin123/article/details/52164101)

[Linux IO模式及 select、poll、epoll详解 - SegmentFault 思否](https://segmentfault.com/a/1190000003063859)