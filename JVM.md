# JVM
## JVM的内存空间
JVM的内存空间分为5个部分

- 程序计数器
- Java虚拟机栈

- 本地方法栈
- 堆
- 方法区

![image-20220715143229321](C:\Users\Caijinyang\AppData\Roaming\Typora\typora-user-images\image-20220715143229321.png)

>JDK 1.8 同 JDK 1.7 比，最大的差别就是：**元数据区取代了永久代**。元空间的本质和永久代类似，都是对 JVM 规范中方法区的实现。不过元空间与永久代之间最大的区别在于：元数据空间并不在虚拟机中，而是使用本地内存。



### 程序计数器（PC寄存器）

**程序计数器的定义**

程序计数器是一块较小的内存空间，是线程正在执行的字节码指令的地址。

如果线程正在执行的是一个本地方法，那么此时的程序计数器为undefined。



**程序计数器的作用**

- 字节码解释器通过改变程序计数器来一次读取指令，从而实现代码的流程控制。
- 在多线程情况下，程序计数器执行的是当前线程执行的位置，当线程切换回来的时候，就知道上次的线程执行到哪儿。



**程序计数器的特点**

- 是一块空间较小的**内存**空间
- 线程私有，每个线程都有一个独立的程序计数器
- 随着线程的生命周期创建和销毁
- 是唯一不会出现OOM错误的区域





### Java虚拟机栈（Java栈）

**Java虚拟机栈的定义**

Java虚拟机栈的是描述Java方法运行的内存模型。

Java虚拟机会为每个即将运行的Java方法分配一块内存，叫做**栈帧**，这个内存空间用于放置该方法运行中的一些信息：

- 局部变量表
- 操作数栈
- 动态链接
- 方法出口信息

<img src="C:\Users\Caijinyang\AppData\Roaming\Typora\typora-user-images\image-20220715154838322.png" alt="image-20220715154838322" style="zoom: 80%;" />

**压栈出栈过程**

当方法过程中需要创建局部变量的时候，就将局部变量的值存放在栈帧的局部变量表中。

**Java 虚拟机栈的栈顶的栈帧是当前正在执行的活动栈，也就是当前正在执行的方法，PC 寄存器也会指向这个地址。**

**只有活动栈的本地变量可以被操作数栈调用。当在这个栈帧中调用另一个方法， 与之对应的新的栈帧又会被创建，新创建的栈帧压入栈顶，变为当前的活动栈帧。**

**方法结束之后，该方法出栈，栈帧的返回值变成新的活动栈帧中操作数栈的一个操作数。如果没有返回值，那么新的活动栈中的操作数不会有任何变化。**

> 由于 Java 虚拟机栈是与线程对应的，数据不是线程共享的（也就是线程私有的)，因此不用关心数据一致性问题，也不会存在同步锁的问题。



**局部变量表**

定义为一个数字数组，主要用于存储方法参数，定义在方法体内部的局部变量，数据类型（包括各种类型的基本数据、对象引用），以及return address类型。

局部变量表的大小是在编译期确定下来的。最基本的存储单位是slot，32位类型占用一个slot，64位类型（long、double）占用两个slot。

> 对于slot的理解：
>
> - JVM会为每一个slot分配一个访问索引，通过这个索引可以直接访问到slot，获取slot地址中的值。
> - 如果当前帧是由构造方法或者实例方法创建的，那么该对象引用this，会存放在index为0的slot处，其余的参数表顺序继续排列。
> - 栈帧中的局部变量表中的槽位是可以重复的，**如果一个局部变量过了其作用域，那么其作用域之后申明的新的局部变量就有可能会复用过期局部变量的槽位**，从而达到节省资源的目的。

**在栈帧中，与性能调优关系最密切的部分，就是局部变量表**，方法执行时，虚拟机使用局部变量表完成方法的传递局部变量表中的变量也是重要的垃圾回收根节点，**只要被局部变量表中直接或间接引用的对象都不会被回收**。



**操作数栈**

- **栈顶缓存**：栈顶元素全部放到CPU的cache中，这样可以降低在内存中频繁读写的时间消耗，提升执行引擎的执行效率。
- 每一个操作数栈都有一个明确的栈深度，用于存储数值，最大深度在编译器就已经规定好，32bit 类型占用一个栈单位深度，64bit 类型占用两个栈单位深度操作数栈。
- 并非采用访问索引方式进行数据访问，而是只能通过标准的入栈、出栈操作完成一次数据访问。



**方法的调用**

- 静态链接：当一个字节码文件被装载进 JVM 内部时，如果被调用的目标方法在编译期可知，且运行时期间保持不变，这种情况下降调用方的符号引用转为直接引用的过程称为静态链接。
- 动态链接：如果被调用的方法无法在编译期被确定下来，只能在运行期将调用的方法的符号引用转为直接引用，这种引用转换过程具备动态性，因此被称为动态链接。
- 方法绑定：
  - 早期绑定：被调用的目标方法如果**在编译期可知**，且运行期保持不变。
  - 晚期绑定：被调用的方法**在编译期无法被确定**，只能够在程序运行期根据实际的类型绑定相关的方法。
- 静态方法：如果方法在编译期就确定了具体的调用版本，则这个版本在运行时是不可变的。这样的方法称为非虚方法静态方法，私有方法，final 方法，实例构造器，父类方法都是非虚方法，除了这些以外都是虚方法。
- 虚方法表：面向对象的编程中，会很频繁的使用动态分配，如果每次动态分配的过程都要重新在类的方法元数据中搜索合适的目标的话，就可能影响到执行效率，因此为了提高性能，JVM 采用在类的方法区建立一个虚方法表，使用索引表来代替查找。
  - **每个类都有一个虚方法表，表中存放着各个方法的实际入口。**
  - 虚方法表会在类加载的链接阶段被创建，并开始初始化，类的变量初始值准备完成之后，JVM 会把该类的方法也初始化完毕。

- 方法重写的本质
  - 找到操作数栈顶的第一个元素所执行的对象的实际类型，记做 C。如果在类型 C 中找到与常量池中描述符和简单名称都相符的方法，则进行访问权限校验。
  - 如果通过则返回这个方法的直接引用，查找过程结束；如果不通过，则返回 java.lang.IllegalAccessError 异常。
  - 否则，按照继承关系从下往上依次对 C 的各个父类进行上一步的搜索和验证过程。
  - 如果始终没有找到合适的方法，则抛出 java.lang.AbstractMethodError 异常。

**Java 中任何一个普通方法都具备虚函数的特征（运行期确认，具备晚期绑定的特点），C++ 中则使用关键字 virtual 来显式定义。如果在 Java 程序中，不希望某个方法拥有虚函数的特征，则可以使用关键字 final 来标记这个方法。**



Java虚拟机栈的特点

- 运行速度快，仅次于PC寄存器。
- 局部变量表随着栈帧的创建而创建，它的大小在编译时确定，创建时只需分配事先规定的大小即可。在方法运行过程中，局部变量表的大小不会发生改变。
- Java虚拟机栈会产生两种错误：StackOverFlowError和OOM。
  - StackOverFlowError：**若 Java 虚拟机栈的大小不允许动态扩展，那么当线程请求栈的深度超过当前 Java 虚拟机栈的最大深度时，抛出 StackOverFlowError 异常。**
  - OutOfMemoryError：若允许动态扩展，那么当**线程请求栈时分配给这个进程的物理内存用完了**，无法再动态扩展时，抛出 OutOfMemoryError 异常。
- **Java 虚拟机栈也是线程私有，随着线程创建而创建，随着线程的结束而销毁。**
- 出现 StackOverFlowError 时，内存空间可能还有很多。



常见的运行时异常有：

- NullPointerException - 空指针引用异常
- ClassCastException - 类型强制转换异
- IllegalArgumentException - 传递非法参数异常
- ArithmeticException - 算术运算异常
- ArrayStoreException - 向数组中存放与声明类型不兼容对象异常
- IndexOutOfBoundsException - 下标越界异常
- NegativeArraySizeException - 创建一个大小为负数的数组错误异常
- NumberFormatException - 数字格式异常
- SecurityException - 安全异常
- UnsupportedOperationException - 不支持的操作异常



### 本地方法栈（C栈）

**本地方法栈的定义**

本地方法栈是为 JVM 运行 Native 方法准备的空间，由于很多 Native 方法都是用 C 语言实现的，所以它通常又叫 C 栈。它与 Java 虚拟机栈实现的功能类似，只不过本地方法栈是描述本地方法运行过程的内存模型。

### 

**栈帧变化过程**

本地方法被执行时，在本地方法栈也会创建一块栈帧，用于存放该方法的局部变量表、操作数栈、动态链接、方法出口信息等。

方法执行结束后，相应的栈帧也会出栈，并释放内存空间。也会抛出 StackOverFlowError 和 OutOfMemoryError 异常。

> 如果 Java 虚拟机本身不支持 Native 方法，或是本身不依赖于传统栈，那么可以不提供本地方法栈。如果支持本地方法栈，那么这个栈一般会在线程创建的时候按线程分配。



























































































