# JVM
## JVM的内存空间
JVM的内存空间分为5个部分

- 程序计数器
- Java虚拟机栈

- 本地方法栈
- 堆
- 方法区

![image-20220715143229321](C:\Users\Caijinyang\AppData\Roaming\Typora\typora-user-images\image-20220715143229321.png)

>JDK 1.8 同 JDK 1.7 比，最大的差别就是：**元数据区取代了永久代**。元空间的本质和永久代类似，都是对 JVM 规范中方法区的实现。不过元空间与永久代之间最大的区别在于：元数据空间并不在虚拟机中，而是使用本地内存。



### 程序计数器（PC寄存器）

**程序计数器的定义**

程序计数器是一块较小的内存空间，是线程正在执行的字节码指令的地址。

如果线程正在执行的是一个本地方法，那么此时的程序计数器为undefined。



**程序计数器的作用**

- 字节码解释器通过改变程序计数器来一次读取指令，从而实现代码的流程控制。
- 在多线程情况下，程序计数器执行的是当前线程执行的位置，当线程切换回来的时候，就知道上次的线程执行到哪儿。



**程序计数器的特点**

- 是一块空间较小的**内存**空间
- 线程私有，每个线程都有一个独立的程序计数器
- 随着线程的生命周期创建和销毁
- 是唯一不会出现OOM错误的区域





### Java虚拟机栈（Java栈）

**Java虚拟机栈的定义**

Java虚拟机栈的是描述Java方法运行的内存模型。

Java虚拟机会为每个即将运行的Java方法分配一块内存，叫做**栈帧**，这个内存空间用于放置该方法运行中的一些信息：

- 局部变量表
- 操作数栈
- 动态链接
- 方法出口信息

<img src="C:\Users\Caijinyang\AppData\Roaming\Typora\typora-user-images\image-20220715154838322.png" alt="image-20220715154838322" style="zoom: 80%;" />

**压栈出栈过程**

当方法过程中需要创建局部变量的时候，就将局部变量的值存放在栈帧的局部变量表中。

**Java 虚拟机栈的栈顶的栈帧是当前正在执行的活动栈，也就是当前正在执行的方法，PC 寄存器也会指向这个地址。**

**只有活动栈的本地变量可以被操作数栈调用。当在这个栈帧中调用另一个方法， 与之对应的新的栈帧又会被创建，新创建的栈帧压入栈顶，变为当前的活动栈帧。**

**方法结束之后，该方法出栈，栈帧的返回值变成新的活动栈帧中操作数栈的一个操作数。如果没有返回值，那么新的活动栈中的操作数不会有任何变化。**

> 由于 Java 虚拟机栈是与线程对应的，数据不是线程共享的（也就是线程私有的)，因此不用关心数据一致性问题，也不会存在同步锁的问题。



**局部变量表**

定义为一个数字数组，主要用于存储方法参数，定义在方法体内部的局部变量，数据类型（包括各种类型的基本数据、对象引用），以及return address类型。

局部变量表的大小是在编译期确定下来的。最基本的存储单位是slot，32位类型占用一个slot，64位类型（long、double）占用两个slot。

> 对于slot的理解：
>
> - JVM会为每一个slot分配一个访问索引，通过这个索引可以直接访问到slot，获取slot地址中的值。
> - 如果当前帧是由构造方法或者实例方法创建的，那么该对象引用this，会存放在index为0的slot处，其余的参数表顺序继续排列。
> - 栈帧中的局部变量表中的槽位是可以重复的，**如果一个局部变量过了其作用域，那么其作用域之后申明的新的局部变量就有可能会复用过期局部变量的槽位**，从而达到节省资源的目的。

**在栈帧中，与性能调优关系最密切的部分，就是局部变量表**，方法执行时，虚拟机使用局部变量表完成方法的传递局部变量表中的变量也是重要的垃圾回收根节点，**只要被局部变量表中直接或间接引用的对象都不会被回收**。



**操作数栈**

- **栈顶缓存**：栈顶元素全部放到CPU的cache中，这样可以降低在内存中频繁读写的时间消耗，提升执行引擎的执行效率。
- 每一个操作数栈都有一个明确的栈深度，用于存储数值，最大深度在编译器就已经规定好，32bit 类型占用一个栈单位深度，64bit 类型占用两个栈单位深度操作数栈。
- 并非采用访问索引方式进行数据访问，而是只能通过标准的入栈、出栈操作完成一次数据访问。



**方法的调用**

- 静态链接：当一个字节码文件被装载进 JVM 内部时，如果被调用的目标方法在编译期可知，且运行时期间保持不变，这种情况下降调用方的符号引用转为直接引用的过程称为静态链接。
- 动态链接：如果被调用的方法无法在编译期被确定下来，只能在运行期将调用的方法的符号引用转为直接引用，这种引用转换过程具备动态性，因此被称为动态链接。
- 方法绑定：
  - 早期绑定：被调用的目标方法如果**在编译期可知**，且运行期保持不变。
  - 晚期绑定：被调用的方法**在编译期无法被确定**，只能够在程序运行期根据实际的类型绑定相关的方法。
- 静态方法：如果方法在编译期就确定了具体的调用版本，则这个版本在运行时是不可变的。这样的方法称为非虚方法静态方法，私有方法，final 方法，实例构造器，父类方法都是非虚方法，除了这些以外都是虚方法。
- 虚方法表：面向对象的编程中，会很频繁的使用动态分配，如果每次动态分配的过程都要重新在类的方法元数据中搜索合适的目标的话，就可能影响到执行效率，因此为了提高性能，JVM 采用在类的方法区建立一个虚方法表，使用索引表来代替查找。
  - **每个类都有一个虚方法表，表中存放着各个方法的实际入口。**
  - 虚方法表会在类加载的链接阶段被创建，并开始初始化，类的变量初始值准备完成之后，JVM 会把该类的方法也初始化完毕。

- 方法重写的本质
  - 找到操作数栈顶的第一个元素所执行的对象的实际类型，记做 C。如果在类型 C 中找到与常量池中描述符和简单名称都相符的方法，则进行访问权限校验。
  - 如果通过则返回这个方法的直接引用，查找过程结束；如果不通过，则返回 java.lang.IllegalAccessError 异常。
  - 否则，按照继承关系从下往上依次对 C 的各个父类进行上一步的搜索和验证过程。
  - 如果始终没有找到合适的方法，则抛出 java.lang.AbstractMethodError 异常。

**Java 中任何一个普通方法都具备虚函数的特征（运行期确认，具备晚期绑定的特点），C++ 中则使用关键字 virtual 来显式定义。如果在 Java 程序中，不希望某个方法拥有虚函数的特征，则可以使用关键字 final 来标记这个方法。**



Java虚拟机栈的特点

- 运行速度快，仅次于PC寄存器。
- 局部变量表随着栈帧的创建而创建，它的大小在编译时确定，创建时只需分配事先规定的大小即可。在方法运行过程中，局部变量表的大小不会发生改变。
- Java虚拟机栈会产生两种错误：StackOverFlowError和OOM。
  - StackOverFlowError：**若 Java 虚拟机栈的大小不允许动态扩展，那么当线程请求栈的深度超过当前 Java 虚拟机栈的最大深度时，抛出 StackOverFlowError 异常。**
  - OutOfMemoryError：若允许动态扩展，那么当**线程请求栈时分配给这个进程的物理内存用完了**，无法再动态扩展时，抛出 OutOfMemoryError 异常。
- **Java 虚拟机栈也是线程私有，随着线程创建而创建，随着线程的结束而销毁。**
- 出现 StackOverFlowError 时，内存空间可能还有很多。



常见的运行时异常有：

- NullPointerException - 空指针引用异常
- ClassCastException - 类型强制转换异
- IllegalArgumentException - 传递非法参数异常
- ArithmeticException - 算术运算异常
- ArrayStoreException - 向数组中存放与声明类型不兼容对象异常
- IndexOutOfBoundsException - 下标越界异常
- NegativeArraySizeException - 创建一个大小为负数的数组错误异常
- NumberFormatException - 数字格式异常
- SecurityException - 安全异常
- UnsupportedOperationException - 不支持的操作异常



### 本地方法栈（C栈）

**本地方法栈的定义**

本地方法栈是为 JVM 运行 Native 方法准备的空间，由于很多 Native 方法都是用 C 语言实现的，所以它通常又叫 C 栈。它与 Java 虚拟机栈实现的功能类似，只不过本地方法栈是描述本地方法运行过程的内存模型。

**栈帧变化过程**

本地方法被执行时，在本地方法栈也会创建一块栈帧，用于存放该方法的局部变量表、操作数栈、动态链接、方法出口信息等。

方法执行结束后，相应的栈帧也会出栈，并释放内存空间。也会抛出 StackOverFlowError 和 OutOfMemoryError 异常。

> 如果 Java 虚拟机本身不支持 Native 方法，或是本身不依赖于传统栈，那么可以不提供本地方法栈。如果支持本地方法栈，那么这个栈一般会在线程创建的时候按线程分配。



### 堆

**堆的定义**

堆用来存放对象的内存空间，几乎所有的对象都存放在堆中。

**堆的特点**

- 线程共享，所有的线程都共享同一个堆，整个Java虚拟机只有一个堆。与之相比较，程序计数器、虚拟机栈、本地方法栈都是每个线程独有的。
- 在虚拟机启动的时候就创建堆。
- 是垃圾回收工作的主要场所。
- 堆可分为新生代（Eden 区：`From Survior`，`To Survivor`）、老年代。
- Java 虚拟机规范规定，**堆可以处于物理上不连续的内存空间中，但在逻辑上它应该被视为连续的。**

堆的不同区域存放着不同生命周期的对象内存，这样可以根据不同的区域使用不同的垃圾回收算法，更加具有针对性。

堆的大小既可以固定也可以扩展，但是对于主流的虚拟机，堆的大小是可以扩展的。当堆的大小已经是最大，并且内存也已经全部分配，此时会抛出OOM异常。



**新生代和老年代**

- 老年代的生命周期比新生代长。
- 新生代与老年代空间默认比例为1: 2 ---- JVM 调参数，`XX:NewRatio=2`，表示新生代占 1，老年代占 2，新生代占整个堆的 1/3。
- HotSpot中，Eden空间和另外两个Survivor空间所缺省的比例是8:1:1。
- 几乎所有的Java对象都是在Eden区被new出来的，Eden存放不了大的对象，会直接进入老年代。



**对象的分配过程**

- new的对象先放在Eden区，大小有限制
- 如果创建新对象，Eden空间填满了，就会触发Minor GC，将Eden不再被引用的对象销毁，再加载新的对象到Eden区，特别注意的是 Survivor 区满了是不会触发 Minor GC 的，而是 Eden 空间填满了，Minor GC 才顺便清理 Survivor 区
- 将Eden中剩余的对象移到Survivor区
- 再次触发垃圾回收，此时上次 Survivor 下来的，放在 Survivor0 区的，如果没有回收，就会放到 Survivor1 区
- 再次经历垃圾回收，又会将幸存者重新放回 Survivor0 区，依次类推

- 默认是 15 次的循环，超过 15 次，则会将幸存者区幸存下来的转去老年区 jvm 参数设置次数 : -XX:MaxTenuringThreshold=N 进行设置
- 频繁在新生区收集，很少在养老区收集，几乎不在永久区/元空间搜集



**Full GC & Major GC触发的条件**

- 显式调用`System.gc()`，老年代的空间不够，方法区的空间不够等都会触发 Full GC，同时对新生代和老年代回收，FUll GC 的 STW 的时间最长，应该要避免
- 在出现 Major GC 之前，会先触发 Minor GC，如果老年代的空间还是不够就会触发 Major GC，STW 的时间长于 Minor GC



**四种引用方式**

[Java的四种引用方式](https://blog.csdn.net/linzhiqiang0316/article/details/88591907)

- 强引用：创建一个对象，并且将整个对象赋给一个引用变量，普通new出来的对象的变量引用都是强引用，有引用变量指向的时候永远不会被GC，JVM宁愿抛出OOM。当一个方法运行结束之后，指向的对象不存在了，JVM会将其回收。如果想中断强引用和某个对象之间的关联，可以显示地将引用赋值为null，这样一来的话，JVM在合适的时间就会回收该对象。

- 软引用：如果一个对象具有软引用，内存空间还足够，GC就不会回收它，如果内存空间不足了，就会回收这些对象的内存，只要垃圾回收器没有回收它，该对象就可以被程序回收。

  ```java 
  MyObject aRef = new  MyObject();  
  SoftReference aSoftRef=new SoftReference(aRef);  
  ```

  此时，对于这个MyObject对象，有两个引用路径，一个是来自SoftReference对象的软引用，一个来自变量aReference的强引用，所以这个MyObject对象是强可及对象。

  随即，我们可以结束aReference对这个MyObject实例的强引用:

  ```java 
  aRef = null;
  ```

  此后，这个MyObject对象成为了软引用对象。如果垃圾收集线程进行内存垃圾收集，**并不会因为有一个SoftReference对该对象的引用而始终保留该对象。**

  Java虚拟机的垃圾收集线程对软可及对象和其他一般Java对象进行了区别对待:软可及对象的清理是由垃圾收集线程根据其特定算法按照内存需求决定的。
  也就是说，垃圾收集线程会在虚拟机抛出OutOfMemoryError之前回收软可及对象，而且虚拟机会尽可能优先回收长时间闲置不用的软可及对象，对那些刚刚构建的或刚刚使用过的“新”软可反对象会被虚拟机尽可能保留。在回收这些对象之前，我们可以通过:

  ```java 
  MyObject anotherRef=(MyObject)aSoftRef.get();  
  ```

  重新获得对该实例的强引用。而回收之后，调用get()方法就只能得到null了。

- 弱引用：弱引用也是用来描述非必需对象的，当JVM进行垃圾回收时，无论内存是否充足，都会回收被弱引用关联的对象。在java中，用java.lang.ref.WeakReference类来表示。下面是使用示例：

  第二个输出结果是null，这说明只要JVM进行垃圾回收，被弱引用关联的对象必定会被回收掉。不过要注意的是，这里所说的被弱引用关联的对象是指只有弱引用与之关联，如果存在强引用同时与之关联，则进行垃圾回收时也不会回收该对象（软引用也是如此）。

- 虚引用：虚引用和前面的软引用、弱引用不同，它并不影响对象的生命周期。在java中用java.lang.ref.PhantomReference类表示。如果一个对象与虚引用关联，则跟没有引用与之关联一样，在任何时候都可能被垃圾回收器回收。



### 方法区

**方法区的定义**

Java虚拟机中的方法区是堆的一个逻辑部分，方法区存放以下信息：

- 已经被虚拟机加载的信息
- 常量
- 静态变量
- 即时编译器编译后的代码



**方法区的特点**

- 线程共享。方法区是堆的一个逻辑部分，因此和堆一样，都是线程共享的。整个虚拟机中只有一个方法区。
- 方法区是永久代。方法区中的信息一般需要长期存在，而且它又是堆的逻辑分区，因此用堆的划分方法，把方法区称为“永久代”。
- 内存回收率低。方法区中的信息一般需要长期存在，回收一遍之后可能只有少量信息无效。主要回收目标是：对常量池的回收；对类型的卸载。
- Java虚拟机对于方法区的要求比较宽松。和堆一样，允许固定大小也允许动态扩展，还允许不GC。



**运行常量池**

方法区中存放：类信息、常量、静态变量、即时编译器编译后的代码，常量就存放在运行时的常量池中。

当类被 Java 虚拟机加载后， .class 文件中的常量就存放在方法区的运行时常量池中。而且在运行期间，可以向常量池中添加新的常量。如 String 类的 `intern()` 方法就能在运行期间向常量池中添加字符串常量。



### 直接内存（堆外内存）

直接内存是除了Java虚拟机之外的内存，但也可能被Java使用。

**操作直接内存**

Java在NIO中引入了一种基于通道和缓冲的 IO 方式。它可以通过调用本地方法直接分配 Java 虚拟机之外的内存，然后通过一个存储在堆中的`DirectByteBuffer`对象直接操作该内存，而无须先将外部内存中的数据复制到堆中再进行操作，从而提高了数据操作的效率。

直接内存的大小不受 Java 虚拟机控制，但既然是内存，当内存不足时就会抛出 OutOfMemoryError 异常。



**直接内存与堆内存比较**

- 直接内存申请空间耗费更高的性能
- 直接内存读取 IO 的性能要优于普通的堆内存
- 直接内存作用链： 本地 IO -> 直接内存 -> 本地 IO
- 堆内存作用链：本地 IO -> 直接内存 -> 非直接内存 -> 直接内存 -> 本地 IO

> 服务器管理员在配置虚拟机参数时，会根据实际内存设置`-Xmx`等参数信息，但经常忽略直接内存，使得各个内存区域总和大于物理内存限制，从而导致动态扩展时出现`OutOfMemoryError`异常。





## Hotspot虚拟机对象































































