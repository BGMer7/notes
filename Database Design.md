# 数据库设计

## 数据库三大范式

**第一范式（1NF）：要求数据库表的每一列都是不可分割的原子数据项。**



**第二范式（2NF）：在1NF的基础上，非码属性必须完全依赖于候选码（在1NF基础上消除非主属性对主码的部分函数依赖）**

**第二范式需要确保数据库表中的每一列都和主键相关，而不能只与主键的某一部分相关（主要针对联合主键而言）。**



**第三范式（3NF）：在2NF基础上，任何非主属性不依赖于其它非主属性（在2NF基础上消除传递依赖）**

**第三范式需要确保数据表中的每一列数据都和主键直接相关，而不能间接相关。**



首先需要明白范式是一个什么样的概念，实际上可以将一个范式理解为一张数据表结构所符合的某种设计标准的级别。

数据库范式分为1NF，2NF，3NF，BCNF，4NF，5NF。一般在我们设计关系型数据库的时候，最多考虑到BCNF就够。

符合高等级范式的设计必定符合低等级范式的要求。

数据库第一二三范式到底在说什么？ - 刘慰的文章 - 知乎 https://zhuanlan.zhihu.com/p/20028672



### 数据库第一范式 1NF

**1NF的要求为，关系中的每个属性都不可再分。**

实际上，1NF是所有关系型数据库的最低要求，如果构建的数据表是不符合1NF要求的，在市面上主流的数据库中，建表的操作是不能成功的。

以此表为例：

| 学号  | 姓名 | 系名     | 系主任 | 课名       | 分数 |
| ----- | ---- | -------- | ------ | ---------- | ---- |
| 95001 | 李勇 | 数学系   | 张清玫 | 复变函数   | 80   |
| 95001 | 李勇 | 数学系   | 张清玫 | 大学英语   | 90   |
| 95001 | 李勇 | 数学系   | 张清玫 | 数学分析   | 70   |
| 95002 | 刘晨 | 计算机系 | 刘逸   | 数据结构   | 60   |
| 95002 | 刘晨 | 计算机系 | 刘逸   | 程序设计   | 80   |
| 95002 | 刘晨 | 计算机系 | 刘逸   | 数据库原理 | 90   |
| 95003 | 王敏 | 数学系   | 张清玫 | 复变函数   | 80   |
| 95003 | 王敏 | 数学系   | 张清玫 | 红楼梦赏析 | 90   |

以上图的表为例，表中的数据仍然存在大量的数据冗余、插入异常、删除异常、修改异常的问题。

1. 每一名学生的学号、姓名、系名、系主任这些数据重复多次。每个系与对应的系主任的数据也重复多次——**数据冗余过大**
2. 假如学校新建了一个系，但是暂时还没有招收任何学生（比如3月份就新建了，但要等到8月份才招生），那么是无法将系名与系主任的数据单独地添加到数据表中去的 （注１）——**插入异常**
3. 假如将某个系中所有学生相关的记录都删除，那么所有系与系主任的数据也就随之消失了（一个系所有学生都没有了，并不表示这个系就没有了）。——**删除异常**
4. 假如李小明转系到法律系，那么为了保证数据库中数据的一致性，需要修改三条记录中系与系主任的数据。——**修改异常**。



### 数据库第二范式 2NF

**2NF在1NF的基础上，消除了非主属性对于码的部分函数依赖。**

首先对于2NF中提及的名词做出解释。

#### 函数依赖

如果在一张表中，在属性（或者属性组）中**X值确定的情况下， 必定能确定下属性Y的值**，那么就说Y依赖于X，写作X->Y。

也就是说，在数据表中，不存在任意两条记录，它们在X属性（或属性组）上的值相同，而在Y属性上的值不同。这也就是“函数依赖”名字的由来，类似于函数关系 y = f(x)，在x的值确定的情况下，y的值一定是确定的。

在上表中，只要学号确定，姓名也可以被确定下来；只要系名确定，系主任也可以被确定下来；只要学号和课名的组合确定下来，分数也可以被确定下来，可以写作：

- 系名->系主任
- 学号->姓名
- 学号->系主任
- （学号，课名）-> 分数



从函数依赖这个概念展开，还有三个函数依赖的概念：

**完全函数依赖，部分函数依赖，传递函数依赖**

**完全函数依赖：** 通过（学号， 课名）可以得到分数，而通过单独的学号或者单独的课名都无法得到该成绩，则说明该生本课程的分数完全依赖于（学号，课名）

**部分函数依赖：**通过（学号， 课名）可以得到姓名，而通过单独的学号已经能够得到姓名，则说明姓名部分依赖于（学号，课名）。

部分函数依赖会导致数据冗余以及各类异常。

**传递函数依赖：**假如 Z 函数依赖于 Y，且 Y 函数依赖于 X （严格来说还有一个X 不包含于Y，且 Y 不函数依赖于Z的前提条件），那么我们就称 Z 传递函数依赖于 X ，记作 X T→ Z。



#### 码/键/Key

设 K 为某表中的一个属性或属性组，若除 K 之外的所有属性都完全函数依赖于 K（这个“完全”不要漏了），那么我们称 K 为**候选码，简称为码**。

在实际中我们通常可以理解为：**假如当 K 确定的情况下，该表除 K 之外的所有属性的值也就随之确定，那么 K 就是码。**

一张表中可以有超过一个码。（实际应用中为了方便，通常选择其中的一个码作为**主键**）primer key

对于上表而言，（学号，课名）这个组合就是这张表的码，该表中有且仅有这一个码。



#### 主属性和非主属性

包含在任意一个码中的属性称为主属性。

不包含在任意一个码中的属性称为非主属性。



根据上述名词再考量2NF的要求，主要有四步：

1. 找出数据表中的码
2. 根据第一步中找出来的码，找出所有的主属性
3. 数据表中除了主属性之外的属性，都是非主属性
4. 查看是否存在非主属性对码的部分函数依赖



第一步：

表中所有的函数依赖关系可以写成：

- 学号->姓名
- 学号->系名
- 系名->系主任
- 学号->系主任（依赖传递，学号->系名->系主任）
- （学号，课名）->分数

第二步：

可见表中的码只有（学号，课名）

第三步：

主属性有两个：学号、课名

第四步：

非主属性有：姓名、系名、系主任、分数

对于**（学号，课名） → 姓名**，有 **学号 → 姓名**，存在非主属性 **姓名** 对码**（学号，课名）**的部分函数依赖。
对于**（学号，课名） → 系名**，有 **学号 → 系名**，存在非主属性 **系名** 对码**（学号，课名）**的部分函数依赖。
对于**（学号，课名） → 系主任**，有 **学号 → 系主任**，存在非主属性 对码**（学号，课名）**的部分函数依赖。

为了让表符合2NF的要求，我们必须消除这些部分函数依赖，**只有一个办法，就是将大数据表拆分成两个或者更多个更小的数据表**，在拆分的过程中，**要达到更高一级范式的要求，这个过程叫做”模式分解“**。



模式分解出两张表：学生表、选课表

选课（学号，课名，分数）
学生（学号，姓名，系名，系主任）对于**选课**表，其码是**（学号，课名）**，主属性是**学号**和**课名**，非主属性是**分数**，**学号**确定，并不能唯一确定**分数**，**课名**确定，也不能唯一确定**分数**，所以不存在非主属性**分数**对于码 **（学号，课名）**的部分函数依赖，所以此表符合2NF的要求。

对于**学生**表，其码是**学号，**主属性是**学号**，非主属性是**姓名、系名**和**系主任**，因为码只有一个属性，所以不可能存在非主属性对于码 的部分函数依赖，所以此表符合2NF的要求。



此时两张表变为：

学生表：
| 学号  | 姓名 | 系名     | 系主任 |
| ----- | ---- | -------- | ------ |
| 95001 | 李勇 | 数学系   | 张清玫 |
| 95001 | 李勇 | 数学系   | 张清玫 |
| 95001 | 李勇 | 数学系   | 张清玫 |
| 95002 | 刘晨 | 计算机系 | 刘逸   |
| 95002 | 刘晨 | 计算机系 | 刘逸   |
| 95002 | 刘晨 | 计算机系 | 刘逸   |
| 95003 | 王敏 | 数学系   | 张清玫 |
| 95003 | 王敏 | 数学系   | 张清玫 |



选课表：

| 学号  | 课名       | 分数 |
| ----- | ---------- | ---- |
| 95001 |  复变函数   | 80   |
| 95001 |  大学英语   | 90   |
| 95001 |  数学分析   | 70   |
| 95002 |  数据结构   | 60   |
| 95002 |  程序设计   | 80   |
| 95002 |  数据库原理 | 90   |
| 95003 |  复变函数   | 80   |
| 95003 |  红楼梦赏析 | 90   |



### 数据库第三范式 3NF

**3NF在2NF的基础之上，消除了非主属性对于码的传递函数依赖**。

也就是说， 如果存在非主属性对于码的传递函数依赖，则不符合3NF的要求。

对于**学生**表，主码为**学号**，主属性为**学号**，非主属性为**姓名**、**系名**和**系主任**。因为 学号 → 系名，同时 系名 → 系主任，所以存在非主属性**系主任**对于码**学号**的传递函数依赖，所以**学生**表的设计，不符合3NF的要求。

为了让数据表设计达到3NF，我们必须进一步进行模式分解为以下形式：
选课（学号，课名，分数）
学生（学号，姓名，系名）
系（系名，系主任）

选课表：

| 学号  | 课名       | 分数 |
| ----- | ---------- | ---- |
| 95001 |  复变函数   | 80   |
| 95001 |  大学英语   | 90   |
| 95001 |  数学分析   | 70   |
| 95002 |  数据结构   | 60   |
| 95002 |  程序设计   | 80   |
| 95002 |  数据库原理 | 90   |
| 95003 |  复变函数   | 80   |
| 95003 |  红楼梦赏析 | 90   |

学生表：
| 学号  | 姓名 | 系名     |
| ----- | ---- | -------- |
| 95001 | 李勇 | 数学系   |
| 95001 | 李勇 | 数学系   |
| 95001 | 李勇 | 数学系   |
| 95002 | 刘晨 | 计算机系 |
| 95002 | 刘晨 | 计算机系 |
| 95002 | 刘晨 | 计算机系 |
| 95003 | 王敏 | 数学系   |
| 95003 | 王敏 | 数学系   |

系表：

| 系名     | 系主任 |
| -------- | ------ |
| 数学系   | 张清玫 |
| 计算机系 | 刘逸   |



由此可见，符合3NF要求的数据库设计，**基本**上解决了数据冗余过大，插入异常，修改异常，删除异常的问题。

当然，在实际中，往往为了性能上或者应对扩展的需要，经常 做到2NF或者1NF，但是作为数据库设计人员，至少应该知道，3NF的要求是怎样的。





















































