# Computer Network Interview

#### OSI的七层协议

OSI的七层协议：物理层、数据链路层、网络层、传输测、会话层、表示层、应用层



#### TCP/IP的五层协议

物理层、数据链路层、网络层、运输层、应用层



#### 物理层的作用

物理层为了解决两台物理机之间的通信，将信号转为二进制编码，主要是通过电流和电压的强弱变化实现，到达目的地之后再转化为二进制机器码。总而言之就是在二进制(bit)与电流之间来回转换。

主要的工作设备有：**中继器**。



#### 数据链路层的作用

通过各种控制协议，将有差错的物理信道变为无差错的、能可靠传输数据帧的数据链路。在不可靠的物理介质上提供可靠的数据传输。

工作原理：接收来自物理层的位流形式的数据，封装成帧传送到上一层。接受来自网络层的数据帧，将数据帧解析为二进制位流，再转发到物理层。

数据链路层通过**差错控制、流量控制方法**，使得有差错的物理层线路变成无差错的数据链路传输，提供**物理寻址**的功能。将二进制数据转换为标准的帧格式(起始位、数据、地址、校验位、结束位)。

主要的工作设备有：**交换机**，**为数据帧从一个端口到另一个任意端口的转发提供了低时延、低开销的通路**。



#### 网络层的作用

数据链路层的数据帧在网络层被封装为数据包

将网络地址翻译成对应的物理地址，并决定通过怎样的路线由发送方发送到接收方，通过**路由选择算法**为通信子网选择最佳路线。

网络层控制数据链路层与传输层之间的信息转发，建立、维持和终止网络的连接。

概括来说，数据链路层的数据在这一层被转换为数据包，然后通过路径选择、分段组合、顺序、进/出路由等控制，将信息从一个网络设备传送到另一个网络设备。

选择数据传输的最优路径，解决网络阻塞问题(**网络阻塞的问题主要是由于CPU需要处理数据，有一定的时间延迟**)

将大数据包切割为小数据包，根据时间的不同最优路径进行传输。

- 寻址

数据链路层中使用的地址都是唯一的物理地址，例如MAC地址，只能够解决网络内部的寻址问题。在不同的网络中，需要识别并且找到网络中的设备，每一个子网中的设备都会分配一个唯一的地址。由于各个子网可能使用不用的物理技术，因此这个唯一的地址使用逻辑地址，通常来说也就是IP地址。

- 交换

信息交换技术，主要有线路交换技术和存储转发技术。后者包含分组转发和报文转发。

- 路由算法

当源节点和目的节点之间存在多条路径时，本层可以根据路由算法，通过网络为数据分组选择最佳路径，并将信息从最合适的路径由发送端传送到接收端。

主要的工作设备有：**路由器，一个作用是连接不同的网络，也就是说路由器一定有两个IP地址，另一个作用是选择数据传播的路线。**



#### 传输层的作用

OSI下3层的主要任务是数据通信，上3层的任务是数据处理。而传输层（Transport Layer）是OSI模型的第4层。因此该层是通信子网和资源子网的接口和桥梁，起到承上启下的作用。传输层的主要作用是定义了一些传输数据的协议和端口号。

传输层提供进程间的逻辑通信，传输层向高层用户屏蔽了下层网络层的实现细节，使应用程序看起来像是在两个传输实体之间有一条端到端的逻辑通信信道。



#### 会话层的作用

用户应用程序和网络之间的接口，主要任务是：向两个实体的表示层**提供建立和使用连接的方法**，在建立会话的时候进行**身份验证**。将不同实体之间的表示层的连接称为会话。会话层的作用就是组织和协调两个会话进程之间的通信，并对数据交换进行管理。

**数据的传输是在会话层完成的，而不是传输层，传输层只是定义了数据传输的协议**



#### 表示层的作用

对数据格式进行编译，对收到的数据根据应用层的特征进行处理，处理为文字、图片、音频、视频、文档等等格式。



#### TCP和UDP

TCP作为面向流的协议，提供的是可靠的、面向连接的传输服务。提供点对点通信。

UDP作为面向报文的协议，不提供可靠交付，并且不需要连接，不仅仅是点对点，也支持多播和广播。



#### 为什么TCP可靠？

1. TCP协议天生具有建立连接三次握手、断开连接四次挥手的机制。

2. 保留**超时重传**的机制。

   当TCP发出一个段后，它启动一个定时器，等待目的端确认收到这个报文段。如果不能及时收到一个确认，将重发这个报文段。

   比如：如果发送方发出了1，2，3，4，5份数据，第一份先到送了，于是就ack回2，结果2因为某些原因没收到，3到达了，于是还是ack回2，后面的4和5都到了，但是还是ack回2，因为2还是没有收到，于是发送端收到了三个ack=2的确认，知道了2还没有到，于是就马上重转2。然后，接收端收到了2，此时因为3，4，5都收到了，于是ack回6。

3. 网络**拥塞控制**。

   TCP协议保证，当网络处于拥塞的状态的时候，减少数据的发送。

4. 滑动窗口机制。

   发送方和接收方各自有一个窗口，接收方建立连接或者发送ACK的时候将自己的窗口大小一并发送，发送方根据接收方的窗口大小进行消息发送。

   发送窗口每发送一个窗口，窗口右移一位。

   接收窗口没交付给主机一位，窗口右移一位。

5. 校验和的差错检验机制。

   对于每一份报文求二进制相加的和并取反，在报文的头部加上对应的检验和字段，如果收到的校验和有差错，TCP将会丢弃这个报文段并且不确认收到这个报文，收到保证了每一份报文的可靠性。

6. TCP的序列号和确认应答机制，TCP给每一个发出的包都会进行编号，并且依次递增，接收方对于数据包进行排序，将有序数据传给应用层。接收方收到有序数据会进行确认。



#### TCP的拥塞控制

如果某段时间之内，网络所能提供的性能资源小于需求，网络的性能就会变差。网络拥塞有两个原因：接收方的容量不够、网络性能到达瓶颈。

网络的参数：由于缺少缓存空间而被丢弃的分组的占比、平均队列长度、超市重传的分组数、分组时延的标准差、，这些指标的上升都标志着网络的拥塞。**一旦出现网络拥塞，就会收到重复的ACK与超时。**

TCP拥塞控制的四个算法：慢开始、拥塞避免、快速重传、快恢复

[面试题—TCP的拥塞控制](https://blog.csdn.net/YL970302/article/details/89434709)



#### 为什么UDP不可靠？

UDP协议是无连接的、尽最大努力交付的协议，没有超时和重传的功能。

UDP协议是面向报文的协议，作为传输层，UDP协议只负责添加首部，之后就下发给IP层，不合并不拆分，保留文本边界。UDP协议一次交付一个完整的报文，因此应用程序应该选用合适的报文长度。

UDP协议由于没有网络拥塞控制，当出现网络拥塞时，并不会影响到发送数据报文的速度，源主机的发送效率并不会降低。对于某些对于实时性要求很高，但是对于丢包率可以接受的应用很有意义。

UDP的首部开销小，对比TCP的20个字节的首部，UDP协议的首部只有8个字节，数据效率高。

发生丢包或者数据丢失的话，UDP不会补发，但是会直接返回发送失败。



#### 什么是TCP粘包

TCP是面向流的协议，是没有界限的一种数据传输，本没有包的概念，粘包和拆包只是为了更加形象地描述。

在Socket网络编程中，都是端到端通信，服务端IP+服务端端口+客户端IP+客户端端口+传输协议组成的五元组可以明确地标识一条连接。

在TCP地Socket网络编程中，客户端和服务端都有socket对。发送端为了将多个发往接收方的包，更加高效地发送给接收方，于是采用了Nagle优化算法。将多个间隔较小、数据量较少的数据，一次性合并成一个数据量大的数据块，然后进行封装。这样一来，接收方也需要设计一种对应的算法将这些包拆分开来。

![img](https://upload-images.jianshu.io/upload_images/23366570-3eb70fe9ba478a01.png?imageMogr2/auto-orient/strip|imageView2/2/format/webp)

正常的情况：两个包刚好满足TCP缓冲区的大小或者达到了TCP的等待时长，分别发送两个包。

粘包：两个包较小，间隔时间短，发生粘包，合并成一个包发送。

拆包：一个包过大，超过缓存区大小，拆分成两个或者多个包发送。

粘包拆包：一个包过大，进行了拆包，而拆出来的包又和别的小包发生了粘包。	



#### TCP粘包的常见处理方法

1. 对于发送方可以直接关闭Negla算法，使用TCP_NODELAY选项来关闭算法。
2. 发送端将每个包的长度都固定，如果不足的话可以使用0补足或者使用空补足。
3. 在包的开头或者结尾添加标志位，使用固定的分隔符。
4. 将包中的数据分为头部和数据部，头部中保存数据的长度。

Netty对于粘包拆包的问题的解决：

LineBasedFrameDecoder: 以行为单位进行数据包解码；

DelimitedBasedFrameDecoder: 以特殊符号作为分割来进行数据包的解码；

FixLengthFrameDecoder: 以固定长度进行数据包的解码；

LengthFieldBasedFrameDecoder: 适用于消息头包含消息长度的协议（最常用）



#### TCP的滑动窗口

滑动窗口是传输层进行流量控制的一种措施，接收方通过通告发 送方自己的窗口大小，从而控制发送方的发送速度，防止发送方发送速度过快而导致自己被淹没。



#### 简述快重传算法

在超时重传的定时器溢出之前，接收到三个连续的重复冗余的ACK，发送端就已经知道有丢包的情况，于是就可以直接开始重传，而不需要等到超时重传的定时器溢出才知道超时。



#### TCP报文中的主要字段

- 端口号(Source Port and Destination Port)：每个端口都包含源端口号和目的端口号，用于寻找发送端和应用端进程。由这两个IP再绑定上发送端和接收端的IP地址就可以建立唯一的TCP连接。
- 序号(Sequence Number)：该字段的作用主要是将失序的TCP报文重新排序，TCP会隐式地对报文地每个字节进行编号，序号是一个32bit的unsigned。
- **确认序号 (Acknowledgment Number)：**接收方在接收到数据之后会回复确认报文，其中包含确认序号。确认序号的作用是告诉对方自己已经收到了哪些信息，下一次的数据从哪里发。因此，确认序号应当是上次已成功收到数据字节序号加 1。并且只有 ACK 标志为 1 时确认序号字段才有效。
- 首部长度(Header Length)：首部的长度是会变的，因此首部长度的字段数值也是会变的。这个字段占 4 bit，4 位的二进制数最大可以表示 15，而首部长度是以 4 个字节为一个单位的，因此首部最大长度是 15 * 4 = 60 字节。
- **控制位(Control Bits)：**一共有六个标志位，在三次握手和四次挥手中都有广泛的运用。
  1. URG(Urgent Bit): 值为1的时候紧急指针生效。
  2. ACK(Acknowledgment Bit): 值为1的时候确认序号生效。
  3. PSH(Push Bit)：接收方应尽快将这个报文段交给应用层。
  4. RST(Reset Bit)：发送端遇到问题，想要重建连接。
  5. SYN(Sychronize Bit): 同步序号，用于发起一个连接。
  6. FIN(Finish Bit): 发送端要求关闭连接。

- 窗口大小 (Window)： TCP的流量控制由连接的每一端通过声明的窗口大小来提供。窗口大小为字节数，起始于确认序号字段指明的值，这个值是接收端正期望接收的字节。窗口大小是一个 16 bit 字段，单位是字节， 因而窗口大小最大为 65535 字节。
- 检验和 (Checksum)：功能类似于数字签名，用于验证数据完整性，也就是确保数据未被修改。检验和覆盖了整个 TCP 报文段，包括 TCP 首部和 TCP 数据，发送端根据特定算法对整个报文段计算出一个检验和，接收端会进行计算并验证。
- 紧急指针 (Urgent Pointer)：当 URG 控制位值为 1 时，此字段生效，紧急指针是一个正的偏移量，和序号字段中的值相加表示紧急数据最后一个字节的序号。 TCP 的紧急方式是发送端向另一端发送紧急数据的一种方式。



 #### 简述TCP建立连接的三次握手过程

1. 第一次握手的过程：

   最一开始的状态是客户端和服务端都是closed的状态，首先由客户端主动发送第一段报文，服务端是被动打开，客户端将SYN置1，随机产生一个seq=x，并将该数据包发送给服务端，然后将客户端的状态设置为SYN_SENT，表示已发送，等待服务端确认。

2. 第二次握手的过程：

   服务端在收到客户端的请求之后，向客户端发送应答第二段报文，其中仍然需要将ACK置1，表示这是确认收到之后做的应答，并且将确认序号字段ack设为x+1，代表服务端期待下次收到的数据包的序号，同时SYN仍然需要置1，表示这是一个用于发起连接的数据报文，同时随机产生一个seq=y，将数据报文发送给客户端，服务端的状态设为SYN_RCVD，表示已经收到，等待客户端确认。

3. 第三次握手的过程：

   客户端收到确认报文之后向服务端发送第三段报文，ACK置1表示确认收到，确认序号字段设为y+1，序号字段seq=x+1，数据开始从x+1发送，此段报文发送完毕之后，双方都进入ESTABLISHED状态，TCP连接已经建立。
   
   ![三次握手过程.png](https://segmentfault.com/img/bVbE4UW)



#### 简述TCP关闭连接的四次挥手过程

建立TCP连接需要三次握手，但是关闭TCP连接需要四次挥手，这是由于TCP的半连接(half-close)造成的。既然一个TCP连接是全双工的，两个方向都能传播，因此每个方向都必须要单独关闭。

这原则就是当一方完成它的数据发送任务后就能发送一个 FIN 来终止这个方向连接。当一端收到一个 FIN，它必须通知应用层另一端已经终止了数据传送。理论上客户端和服务器都可以发起主动关闭，但是更多的情况下是客户端主动发起。

1. 第一次挥手的过程：

   刚开始双方都处于ESTABLISHED的状态，客户端想要主动断开，发送报文，FIN=1，请求关闭连接，并且客户端开始停止发送数据。序号字段 seq=x (等于之前发送的所有数据的最后一个字节的序号加一)，发送后客户端变成了FIN_WAIT_1状态。注意, 这时候客户端同时也变成了half-close(半关闭)状态，即无法向服务端发送报文，只能接收。

2. 第二次挥手的过程：

   服务端收到FIN的信号之后，发回确认报文，ACK=1，ack=x+1，并且带上自己的seq=y，此时服务端也进入CLOSE_WAIT的状态。服务器还会通知上层的应用程序对方已经释放连接，此时 TCP 处于半关闭状态，也就是说客户端已经没有数据要发送了，但是服务器还可以发送数据，客户端也还能够接收。

3. 第三次挥手的过程：

   客户端收到服务器的 ACK 报文段后随即进入 FIN-WAIT-2 状态，此时还能收到来自服务器的数据，直到收到 FIN 报文段。

   服务器发送完所有数据后，会向客户端发送 FIN 报文段，ACK和ack还是为1和x+1， 序号字段seq=z，随后服务器进入 LAST_ACK 状态，等待来自客户端的确认报文段。

4. 第四次挥手的过程：

   客户端收到来自服务器的 FIN 报文段后，向服务器发送 ACK 报文，随后进入 TIME_WAIT 状态，等待 2MSL(2 * Maximum Segment Lifetime，两倍的报文段最大存活时间) ，这是任何报文段在被丢弃前能在网络中存在的最长时间，常用值有30秒、1分钟和2分钟。如无特殊情况，客户端会进入 CLOSED 状态。

   服务端在接收到客户端的 ACK 报文后会随即进入 CLOSED 状态，由于没有等待时间，一般而言，服务端比客户端更早进入 CLOSED 状态。

![preview](https://segmentfault.com/img/bVbE4Va/view)



#### TCP的连接为什么要三次握手而不是两次？

1. 防止已过期的连接请求报文突然又传送到服务器，因而产生错误。如果只是需要客户端发请求报文A，服务端收到请求，服务端再发出请求报文B，此时服务端已经是ESTABLISHED状态，这样只发出来两个报文。如果报文A在传输中丢包，过了一段时间之后再超时重传，可能那时候客户端已经是另外的状态，那么服务端的ESTABLISHED状态就是在浪费资源。
2. 三次握手才能让双方均确认自己和对方的发送和接收能力都正常。
3. 告知对方自己的初始序号值，并确认收到对方的初始序号值。如果是两次握手，只有发起方的初始序号可以得到确认，而另一方的初始序号则得不到确认。



#### TCP的断开为什么要四次挥手而不是三次？

因为TCP是全双工通道，也就是说，客户端和服务端都可以向另一边发送消息。当客户端准备关闭连接的时候，先发出FIN报文，此时服务端收到，但是服务端可能还有东西没有发完，但是服务端仍然需要给客户端发送一条消息表示它已经收到了关闭请求。等到服务端完全发完之后，再给客户端发送一条FIN报文，此时客户端再发出应答，状态变为CLOSED，然后服务端收到之后也变为CLOSED。



#### 简述TCP的半连接队列和全连接队列

三次握手前，服务端的状态从CLOSED变成LISTEN，服务端收到之后恢复ACK和SYN，状态由LISTEN变成SYN_RCVD，此时这个连接就被推进的半连接队列(Syn Queue)。

三次握手之后，客户端返回ACK，服务端收到，状态变为ESTABLISHED，这个时候连接等待被具体的应用取走，在被取走之前，它会被推入另外一个 TCP 维护的队列，也就是全连接队列(Accept Queue)。

半连接队列：TCP三次握手中存放SYN_SENT状态的连接

全连接队列：TCP三次握手中存放ESTABLISHED状态的连接



#### TCP连接机制漏洞/SYN攻击

当服务器在收到了SYN报文之后，会分配并初始化连接变量和缓存，并向客户端发送 SYN + ACK 报文段，这相当于是打开了一个“半开连接 (half-open connection)”，会消耗服务器资源。如果客户端此时返回ACK报文，那么就成功建立了连接，否则服务器会等待一分半钟之后再回收资源。这个机制为SYN攻击提供了机会。

DoS攻击中的SYN flood通过发送大量的SYN报文，但是不发送ACK报文，导致整个缓存池被全部占用，正常的TCP请求无法抢占资源建立连接，从而达到拒绝服务的目的。



#### SYN flood攻击的常见解决办法

1. 增加半连接池的容量，这样攻击方就需要更多的攻击报文，攻击的成本就增加了。
2. 记录IP，若连续受到某个IP的重复SYN报文，从这个IP地址来的包会被一概丢弃。
3. 减小超时重传的timeout。
4. SYN cookie技术。原理是syn报文首先由DDOS防护系统来响应syn_ack。带上特定的sequence number （记为cookie）。真实的客户端会返回一个ack 并且Acknowledgment number 为cookie+1。 而伪造的客户端，将不会作出响应。这样我们就可以知道那些IP对应的客户端是真实的，将真实客户端IP加入白名单。下次访问直接通过，而其他伪造的syn报文就被拦截。



#### TCP关闭连接为什么客户端要等待2MSL？

如果客户端没有等待，直接关闭客户端，有可能客户端的这个端口就会被其他应用立即占用，那么还没发完的服务端消息还在往这个端口发送，就发送到了别的应用，造成了数据混乱。如果等待时间，确保此次服务端的消息该发的都已经发完，那么再关闭客户端是最保险的做法。

2个MSL的意义在于：1个MSL用于确保关闭发起方的最后一个ACK可以到达另一方；1个MSL用于如果最后一个ACK没有发送到对方的话，超时重传的FIN还能到达。



#### TCP连接的KeepAlive机制

由于TCP并不是一个轮询的协议机制，当一方由于网络状况或者宕机而导致连接失效的时候，在下一个数据包到达之前，另一方对此是一无所知的。那么连接如果一直没有释放，对于服务器而言，负担是很大的，对于系统和资源而言都是浪费。此时就出现了KeepAlive机制，作用就是检测这个连接是否失效。

```shell
在linux下查看KeepAlive的相关参数
1. sudo sysctl -a | grep keepalive 
2. // 每隔 7200 s 检测一次 
3. net.ipv4.tcp_keepalive_time = 7200 
4. // 一次最多重传 9 个包 
5. net.ipv4.tcp_keepalive_probes = 9 
6. // 每个包的间隔重传间隔 75 s 
7. net.ipv4.tcp_keepalive_intvl = 75 
```

当一个TCP连接建立之后，启用了KeepAlive的那一端就会启动一个定时器，也就是tcp_keepalive_time参数，当这个数字变为0之后，一个TCP包就发出，这个探测包是一个纯ACK包，其seq和上一个包是一样的，因此不在窗口控制的范围之内。

当这个包发出之后，对方此时有四种状态：

1. 运行正常、服务端可达，客户端的响应报文也就正常反馈，服务端将保活定时器复位，重新计时。
2. 客户端已经崩溃，正在关闭或者重启，那么服务端每隔tcp_keepalive_intvl个时间（一般是75s），就发送一个探测包，一共会再发送tcp_keepalive_probes 9个，如果服务端还没有收到响应，就认为这个客户端已经关闭并且终止。
3. 客户端崩溃但是已经重启，服务端将会收到一个响应，但是这个响应是一个复位响应，使得这个服务器终止这个连接。
4. 客户端运行正常，但是不可达，那么也没有响应，结果与2类似。

TCP Keepalive不是TCP规范的一部分，有几点需要注意：

- 在短暂的故障期间，它们可能引起一个良好连接（good connection）被释放（dropped）
- 它们消费了不必要的宽带
- 在以数据包计费的互联网消费（额外）花费金钱
- 7200s 也就是两个小时检测一次，时间太长
- 时间再短一些，也难以体现其设计的初衷, 即检测长时间的死连接

所以KeepAlive是一个有些尴尬的机制，绝大多数TCP应用并未默认打开这个选项。



#### TCP的KeepAlive和HTTP的Keep-Alive的关系

HTTP中的连接有短连接和长连接之分，短连接的机制是，每一次任务都会新建一个连接，任务结束之后就会关闭这个连接。如果客户端浏览器访问的某个HTML资源中包含CSS、JS、图片等其他文件，浏览器没遇到一个Web资源，都会新建一个HTTP会话。

但从 HTTP/1.1起，默认使用长连接，用以保持连接特性。使用长连接的HTTP协议，会在响应头加上Connection、Keep-Alive字段。

使用长连接的话，开启长连接网页完成打开后，底层用于传输数据的TCP连接不会直接关闭，会根据服务器设置的保持时间保持连接，保持时间过后连接关闭。



#### 简述DNS的解析过程

DNS 是域名系统(Domain Name System，缩写：DNS)是互联网的一项服务。它将域名和IP地址相互映射的一个分布式数据库，在数据库中保存域名与IP的对照关系，从而使人更方便地访问互联网。

DNS解析是分布式存储的，从**结构上来说**最顶层是根域名服务器(ROOT DNS Server)，存储260个顶级域名服务器的IP地址。**对于Ipv4来说**全球有13个根域名服务器，它储存了每个域(如.com .net .cn)的解析和域名服务器的地址信息。**简单的说，根域名服务器就是存放顶级域名服务器地址的。**

在根域名服务器下一级就是，顶级域名服务器。例如.com的域名服务器，存储的是一些一级域名的权威DNS服务器地址。顶级域名分为三类：

- gTLD(generic top-level domains，gTLD)国际顶级域名，例如：.com/.net/.org
- ccTLD(country code top-level domains，ccTLD)国家和地区顶级域名，例如：.cn/.jp
- new gTLD，新顶级域名，例如：.xyz/.top/.red/.help等新顶级域名。

顶级域名服务器下面就是本地域名服务器(Local DNS)，一般就是运营商的DNS服务器。

从结构上，DNS分为三层结构，根服务器->顶级域名服务器->本地域名服务器。

1. 客户机发起一个DNS查询请求，在本地计算机缓存中查找，如果没有找到，将这个请求发送给DNS服务器。
2. 本地DNS服务器先是在自己的区域中找，找到就根据这个记录进行解析，如果没有找到就在本地缓存中查找。
3. 本地的DNS服务器没有找到的话，就把请求转发给DNS根域名服务器。
4. 根域名服务器解析根域名部分，并且将下一级域名的地址返回给客户机。
5. 客户机的DNS服务器根据返回的信息接着访问下一级的DNS服务器。
6. 这样递归的方式一级一级查询，最后在有目标域名的服务器上得到相对应的IP信息。
7. 客户机的本地DNS服务器将查询结果返回给客户端。
8. 客户端根据返回到的IP地址访问目标主机，完成DNS解析。



#### 简述浏览器输入URL到解析出页面的全过程

天龙八步：

1. 根据域名，进行DNS的域名解析
2. 拿到解析出来的IP地址，建立TCP连接
3. 向IP地址发送HTTP请求
4. 服务器处理请求
5. 返回响应结果
6. 关闭TCP连接
7. 浏览器渲染布局

其中：一个TCP连接可以对应几个HTTP请求？/HTTP1.1与1.0的区别

一个TCP连接中HTTP请求发送可以一起发送吗？/HTTP1.1与2.0的区别

浏览器对于同一个host建立TCP连接的数量有没有限制？



#### DNS使用的是什么传输层协议？

DNS协议运行在UDP协议之上，使用端口号53。

但是DNS解析过程中，在区域传送这一段使用的TCP协议。

DNS的协议规范中，规定了DNS有两个服务器，一个主服务器，一个辅助服务器。



#### HTTP协议常见状态码

HTTP协议，超文本传输协议。**HTTP 是一个在计算机世界里专门在「两点」之间「传输」文字、图片、音频、视频等「超文本」数据的「约定和规范」**

| 响应码 | 具体含义                                             | 常见的状态码  |
| ------ | ---------------------------------------------------- | ------------- |
| 1xx    | 提示信息，表示现在是协议的中间状态，还需后续操作。   |               |
| 2xx    | 成功，报文已经被成功收到并被正确处理。               | 200、204、206 |
| 3xx    | 重定向，资源位置发生了变动，需要客户端重新发送请求。 | 301、302、304 |
| 4xx    | 客户端发生请求，请求报文有误，服务端无法处理。       | 400、403、404 |
| 5xx    | 服务器有错误，服务器在处理请求的手内部出现了问题。   | 500、501、502 |

最常见的几个状态码：

200:OK 请求成功，一般用于GET和POST

204:no content 请求成功，但是没有结果返回

206: partial content 客户端请求一部分资源，服务端成功响应，返回一部分资源

301:move permanently 资源永久重定向，资源已经不在了，需要使用新的url再次访问

302: found 临时重定向，资源

400: bad request 请求报文存在语法错误

401: unauthorized 需要认证（第一次返回）认证失败（第二次返回）

403: forbidden 请求背服务器拒绝

404: not found 服务器上无法找到请求的资源

500: internal server error 服务器执行请求时候发生了错误

502: bad gateway 通常是服务器作为网关或者代理的时候返回的响应码，表示该服务器工作正常，但是后端的服务器出现故障

503: service unavailable 服务器正在超负载工作或者正在停机维护



#### 简述cookie、session和token

HTTP协议是一个无状态的协议，上一次请求和下一次请求之间没有任何关联，这样无状态的好处是很快速。

从一个客户端通过HTTP协议访问服务端的过程：

1. 客户端向服务端发送HTTP请求。
2. 服务端接收到客户端的请求，建立一个session，并且发送一个HTTP响应到客户端，这个响应头中包含了set-cookie头部，该头部包含了sessionid。
3. 客户端拿到了sessionid之后发起第二次请求，此时浏览器会在请求中自动加上cookie。
4. 服务器收到请求，分解cookie，与自己之前发出去的cookie的信息比对，将比对结果返回给客户端。

目前的解决方案大多数是session+cookie，使用session只需要客户端保存一个sessionid，其余的大量访问数据保存在服务端，如果全用cookie的话，数据量大的时候，请求的速度会变慢，而且客户端也没有那么大的空间用来存储。

**cookie和session的区别：**

1. cookie存储在客户端，session存储在服务端。
2. cookie不是很安全，因为保存在客户端的本地的cookie有可能会被读取，利用cookie进行欺骗。
3. cookie因为存在本地，所以会减轻服务端的负担。当访问增多的时候，session会占用服务器性能。
4. 将登录信息等重要信息保存在session中，其余的信息如果需要保留可以存放在cookie中。

token的意思是令牌，最简单的token由uid(用户唯一身份标识码)、time(时间戳)、sign(签名，由token的前几位+salt+hash压缩成一定长的十六进制字符串)、一些不变的参数(用于减轻数据库的负担)。

**token的认证流程：**

token的认证流程类似于cookie

1. 客户端发起登录请求，验证成功之后，服务端签发token，返回给客户端。
2. 客户端将这个token保存在本地。
3. 客户端下次再访问的时候，将token放入headers中
4. 服务端采用filter校验，校验成功就返回请求的数据，校验失败就返回错误码。

三种认证方式的注意点：

session是有状态的，一般存放于服务器的内存或者硬盘中，但是当服务器采用的是分布式架构或者集群的时候，就要面对负载均衡的问题。如果采用了负载均衡，因为多个服务器是不共享session的，所以如果均衡到另一台服务器上，就无法判断session的状态。而token是无状态的，客户端每次只需要拿着token发给服务端，服务端接受到token之后，解析并且验证即可。这个方法就是JWT(JSON Web Token)。



#### 简述转发和重定向的区别

转发：是在服务器内部控制权的转移，是由服务器区请求，客户端并不知道是怎样转移的，因此客户端浏览器的地址不会显示出转向的地址。对request对象的信息不会丢失，因此可以在多个页面交互过程中实现请求数据的共享。
重定向：是服务器告诉了客户端要转向哪个地址，客户端再自己去请求转向的地址，因此会显示转向后的地址，也可以理解浏览器至少进行了两次的访问请求。request的数据将会丢失。



#### 简述GET和POST的区别

Get 方法的含义是请求从服务器获取资源，这个资源可以是静态的文本、页面、图片视频等。

而POST 方法则是相反操作，它向 URI 指定的资源提交数据，数据就放在报文的 body 里。

**安全和幂等**：在HTTP中，安全指的是，请求不会破坏或者修改服务器上的资源。幂等指的是多次执行相同的操作，结果都是相同的。

因此GET只是请求服务器上的资源，因此是安全和幂等的。但是POST是新增或者提交数据的操作，因此是不安全的，由于每一次提交都会有修改，因此如果多次操作也不能保证都是一样的，因此也不是幂等的。



#### 简述HTTP和HTTPS

HTTP协议的信息传输采用的是明文传输，并且连接的双方没有办法验证对方身份，存在安全风险的问题。HTTPS采用SSL加密，报文得以加密传输。

HTTP 连接建立相对简单， TCP 三次握手之后便可进行 HTTP 的报文传输。而 HTTPS 在 TCP 三次握手之后，还需进行 SSL/TLS 的握手过程，才可进入加密报文传输。加密采用的是对称加密，双方可以验证身份。

SSL全称为Secure Sockets Layer安全套接层，其继任为TLS(Transport Layer Security, 传输层安全协议)，均用于在传输层为数据通讯提供安全支持。



#### HTTPS的连接过程

1. 浏览器将支持的加密算法发送给服务器。
2. 服务器选择一个浏览器支持的加密算法，以证书的形式发送回给浏览器。
3. 客户端(SSL/TLS)解析证书验证证书的合法性，生成对称加密的密钥CK，再使用服务端的公钥public，对客户端的密钥钥进行非对称加密。
4. 客户端发起HTTPS中的第二个请求，将加密好的客户端私钥发送给服务器。
5. 服务器接受到来自客户端的加密好的密钥，使用服务端自己的私钥private对于客户端的密钥进行解密。解密出来的明文就已经是客户端的密钥CK，这样子服务端得到了客户端的密钥，且传输过程中是使用服务端的公钥私钥加密传输的。拿到客户端的密钥之后，使用这个密钥CK对于数据进行加密，得到密文。
6. 把密文返回给客户端。
7. 因为这个密文本身就是使用客户端的密钥加密的，因此客户端再直接使用自己的密钥进行解密即可，得到了服务端传回的数据明文。



##### 参考文章

[面试准备 TCP 知识，看这一篇就够了 - SegmentFault 思否](https://segmentfault.com/a/1190000022144695)

[计算机网络八股文背诵版 - 知乎 (zhihu.com)](https://zhuanlan.zhihu.com/p/366839763)

[TCP协议面试灵魂10问，建议收藏 - 51CTO.COM](https://network.51cto.com/art/202007/620326.htm)

[KeepAlive详解 - 简书 (jianshu.com)](https://www.jianshu.com/p/9fe2c140fa52)

[计算机TCP/IP面试10连问，你能顶住几道? - SegmentFault 思否](https://segmentfault.com/a/1190000037741102?utm_source=sf-similar-article)

[面试官:讲讲DNS的原理？ - 知乎 (zhihu.com)](https://zhuanlan.zhihu.com/p/79350395)

[不再惧怕DNS面试题：大牛用1张大图，9个步骤轻松应对 - 51CTO.COM](https://network.51cto.com/art/202003/613009.htm)

[硬核！30 张图解 HTTP 常见的面试题 - 知乎 (zhihu.com)](https://zhuanlan.zhihu.com/p/112010468)

[HTTP常见面试题_日积月累的质变-CSDN博客_http面试](https://blog.csdn.net/yicixing7/article/details/79320821)
