# Software Architecture

[干货：软件架构发展历程 - 云+社区 - 腾讯云 (tencent.com)](https://cloud.tencent.com/developer/article/1391404)

### 什么是架构？

人们一直在寻求找到这些问题的解决办法。然而 Fred Brooks 在 1975 年出版的软件工程圣经《人月神话》中说，没有（能解决所有问题的）银弹（There is no silver bullet）。

软件架构是一个用于指导系统实现的草图，这个草图越详细对于系统实现的指导意义越重大，贯穿于软件的整个生命周期。

在建筑领域，大楼尚未建造前，就已经存在于建筑师的脑海里；同样地，系统开始编写第一行代码之前，就已经存在于软件架构师的心里。

### 几个概念

#### 模式（Pattern）

UML 中给出的解释更通俗易懂：模式是对于普遍问题的普遍解决方案。

我们可以把一类问题的共性抽象出来，这样就可以用同样的处理办法去解决这些问题，从而形成模式，所以模式是一些经验的总结。

#### 类库（Library）

类库是一组可复用的功能或工具的集合，应用系统通过调用它们从而达到复用功能的目的。

例如，Windows 应用开发里的各种静态或动态链接库 DLL 文件，Java 开发中项目里依赖的或者 Maven 中央库里的各种 jar 包，都是 Library，比如 Apache Commons IO、Log4j 等。

#### 框架（Framework）

框架是基于一组类库或者工具，在特定领域里根据一定的规则组合成的、开放性的应用骨架。

比如SSM框架，更大范围来说，.Net JDK都算是一种框架。

#### 模块（Module）

模块是业务或系统的安装特定维度的一种切分，同时也可以看做是各种功能按照某种分类聚合的一种形式。

例如我们的一个电商系统，可以从业务上划分为用户模块、商品模块、订单模块、支付模块、物流模块、售后模块等。

另一方面，我们也可以说用户模块聚合了用户注册、用户验证等业务功能。

#### 组件（Component）

组件是一组可以复用的业务功能的集合，包含一些对象及其行为。

组件可以直接被用做业务系统的组成部分，粒度一般小于模块，也是一种功能的聚合形式。比如日志组件、权限组件等。

#### 服务（Service）

服务是一组对外提供业务处理能力的功能，服务需要使用明确的接口方式（比如 SOAP或 REST 等）。

服务描述里应该包括约束和策略（比如参数、返回值，使用什么通讯协议和数据格式等）。

#### 平台（Platform）

平台一般来说，是一个领域或方向上的生态系统，是很多解决方案的集大成者，提供了很多的服务、接口、规范、标准、功能、工具等。

例如 J2EE 平台，包含了企业级应用开发里的各种基于 Java 语言和 JVM 虚拟机运行时的技术能力。



知乎社区编程领域优秀问题回答者 ze ran 说：

> 库是工具箱。 框架是一套通用的解决方案。 架构是高度抽象的需求，是系统中的不变量。 平台是所有可能做的事的集合。



### 软件生命周期

#### 设计阶段

在设计期，软件作为一个成品还不存在，所以我们可以称之为概念形态。

此时架构师、产品经理或需求分析师等人员利用自己的经验能力，对系统的业务需求进行分析、拆解、抽象，形成业务文档和技术文档，以及技术验证代码等。

- 系统分拆：如何把系统拆解为不同的子系统、模块、业务单元；
- 技术选型：使用什么样的基础技术框架或脚手架；
- 技术验证：确定核心技术难点如何解决，检验能否满足期望指标；
- 接口规范：系统的内部不同部分以何种形式确定接口契约和数据通信；
- 集成方式：系统与外部其他业务系统如何进行集成；
- 技术规范：如何规范开发、测试、部署和[运维](https://cloud.tencent.com/solution/operation?from=10680)的技术标准性；
- 部署方案：系统如何进行物理部署，需要多少机器、什么配置，对网络有什么要求；
- 运维方案：系统如何进行技术性运维，如何日常监控、预警报警；

#### 实现阶段

- 确保各项技术规范和技术指标的执行落地，保障高质量的代码；
- 指导研发人员和解决各类技术问题，提升研发团队效率；
- 制定测试的技术性方案和基准，自动化、性能、安全等；
- 配合准备部署环境，运维实施方案落地等。

#### 运行阶段

- 发布上线相关基础性工作，包括是否使用[持续集成](https://cloud.tencent.com/product/coding-ci?from=10680)（CI)、自动化发布等技术；
- 运维基础性工作，自动化运维，监控等相关技术。



### 架构风格

典型的企业级应用系统或者互联网应用系统一般都是通过 Web 提供一组业务服务能力。

这类系统包括提供给用户操作的、运行于浏览器中、具有 UI 的业务逻辑展示和输入部分，运行于服务器端、用后端编程语言构建的业务逻辑处理部分，以及用于存储业务数据的关系数据库或其他类型的存储软件。

根据软件系统在运行期的表现风格和部署结构，我们可以粗略地将其划分为两大类。

（1）整个系统的所有功能单元，整体部署到同一个进程（所有代码可以打包成 1 个或多个文件），我们可以称之为 “单体架构”（Monolithic Architecture）；

（2）整个系统的功能单元分散到不同的进程，然后由多个进程共同提供不同的业务能力，我们称之为 “分布式架构”（Distributed Architecture）。

#### 单体架构

- **简单单体模式：**代码层面没有拆分，所有的业务逻辑都在一个项目（Project）里打包成一个二进制的编译后文件，通过这个文件进行部署，并提供业务能力；

- **MVC 模式：**系统内每个模块的功能组件按照不同的职责划分为模型（Model）、视图（View）、控制器（Controller）等角色，并以此来组织研发实现工作；
- **前后端分离模式：**将前后端代码耦合的设计改为前端逻辑和后端逻辑独立编写实现的处理模式；
- **组件模式：**系统的每一个模块拆分为一个子项目，每个模块独立编译打包成一个组件，然后所有需要的组件一起再部署到同一个容器里；
- **类库模式：**A 系统需要复用 B 系统的某些功能，这时可以直接把 B 系统的某些组件作为依赖库，打包到 A 系统来使用。

#### 分布式架构

- **面向服务架构**（Service Oriented Architecture）：以业务服务的角度和服务总线的方式（一般是 SOAP 与 ESB）考虑系统架构和企业 IT 治理；

- **分布式服务架构**（Distributed Service Architecture）：基于去中心化的分布式服务框架与技术，考虑系统架构和服务治理；

- **微服务架构**（Microservices Architecture）：微服务架构可以看做是面向服务架构和分布式服务架构的拓展，使用更细粒度的服务（所以叫微服务）和一组设计准则来考虑大规模的复杂系统架构设计。

#### 架构的发展历史

- 单体架构
- 垂直架构
- SOA架构
- 微服务架构



#### 经典架构风格

##### 简单单体架构

单体架构是最简单的架构方式，所有的代码都在一个项目中，这样研发团队的每个人都能随时修改任意一段代码或者增加新的代码。

开发人员也可以只需要在自己电脑上就完成代码开发、调试、测试整个系统的功能。

也不需要额外的一些依赖条件和准备步骤，我们就可以直接编译打包整个系统代码，创建一个可以发布的二进制版本。

这种方式对于一个新团队的创立初期，需要迅速开始从 0 到 1，抓住时机实现产品最短时间推向市场，可以省去各种额外的设计，直接上手干活，争取了时间，因而是非常有意义的。

但是这种方式对于一个系统的长期稳定发展确实有很多坏处的。

1. **简单单体架构的代码耦合性很高。**所有的代码都在一起，就算是按照 package 来切分了不同的模块，各不同模块的代码还是可以直接相互引用。修改代码会出现不可预知的bug，而且找到bug的产生位置会很难。
2. **版本的发布与部署存在大量的问题。**系统作为一个单体部署，每次发布的部署单元就是一个新版本的整个系统，系统内的任何业务逻辑调整**都会导致整个系统的重新打包，部署、停机、再重启**，进而导致了系统的停机发布时间较长。
3. 当代码量急剧增大之后，编译耗时很长、系统启动时间很长。
4. 扩展性受到限制。

##### MVC架构

MVC 也是一个非常常见的 3 层（3-Tier）结构架构模式，它把每个模块划分为模型层（Model Layer）、视图层（View Layer）、控制器层（Controller Layer）等部分。

- 模型层：代表业务数据实体部分；

- 视图层：代表前端的展示部分；

- 控制器层：代表请求分发，处理调度部分。

MVC之所以流行开来，主要是因为：

1. 简单直观，上手简单，作为Web系统设计的一般方法；
2. 可以通过切割将系统分为小单元；
3. 不同的模块和分层结构，本身就可以作为一个开发层面的子项目拆分结构，这样我们就可以把系统拆分成多个不同的子项目；
4. 基于 MVC 模式，又陆续发展了 ORM 等简化数据操作层的技术与框架，以及相应的代码生成工具等，极大的提供了软件开发效率。

##### 前后端分离架构

前端团队负责前端系统开发，后端团队负责后端系统开发，两个团队一起制定前后端系统的数据接口。

只要数据接口保持稳定不变，那么前后端系统可以各自独立发展和维护。这一条准则不仅仅是单体架构独有的，所有的 Web 系统都可以按照这种方式进行设计。

前后端分离模式一直影响到现在的系统架构方法，成为了当下的一种最佳实践。目前最主流的三种前端开发框架（React、AngularJS、Vue），都遵循着这种设计理念。

##### SOA架构

[SOA/软件架构设计---面向服务的架构（SOA详细解释）-soa (uml.org.cn)](http://www.uml.org.cn/soa/202004152.asp?artid=23177)

面向服务架构（SOA）是一种建设企业 IT 生态系统的架构指导思想。SOA 的关注点是服务。服务最基本的业务功能单元，由平台中立性的接口契约来定义。

SOA是一种构造分布式系统的方法，它将业务应用功能以服务的形式提供给最终用户应用或其他服务。

- 面向服务的分布式计算
- 服务间松散耦合
- 支持服务的组装
- 服务的注册和自动发现
- 以服务契约方式定义服务交互方式

##### 微服务架构

定义：围绕业务领域组件来创建应用，这些应用可独立地进行开发、管理和迭代。在分散的组件中使用云架构和平台式部署、管理和服务功能，使产品交付变得更加简单。

以下是Martin Fowler对于微服务架构的典型特征的描述：

- 分布式服务组成的系统
- **按照业务而不是技术来划分组织**
- 做有生命的产品而不是项目
- 智能化服务端点与傻瓜式服务编排
- 自动化运维
- 系统容错
- 基础设施自动化
- 服务快速演化
- 去中心化的治理技术和管理数据

| SOA                                                     | 微服务                                                       |
| ------------------------------------------------------- | ------------------------------------------------------------ |
| 强调业务集成、业务流程编排，典型代表Web Service和ESB    | 使用一系列小服务实现整体流程，目的是有效拆分应用             |
| 将多个业务服务打包在一个war包，统一部署到一个应用服务器 | 拆分成小服务之后，通常使用敏捷扩容、缩容的docker技术来实现自动化的容器管理，每个微服务运行在单一的进程内，微服务中的部署相互独立、互不影响。 |
| SOA对于粒度，没有要求                                   | 微服务倡导将服务拆分成更细的粒度                             |



## Microservices

### 松耦合和高内聚

一个松耦合的服务应该尽可能少地知道与之协作的那些服务的信息。这也意味着，应该限制两个服务之间不同调用形式的数量，因为除了潜在的性能问题之外，过度的通信可能会导致紧耦合。



### 限界上下文

准确来说，确定领域范围的就是限界上下文边界，限界上下文边界英文名bounded context，如果直接翻译成上下文边界就更容易理解，主要目的是为了避免同样的概念在不同领域产生不同语义或歧义，DDD在战略上提出"限界上下文"这个概念，用来确定语义所在的领域边界。

我们可以将限界上下文拆解成两个词语：限界和上下文。限界就是领域的边界，而上下文就是语义环境，通过限界上下文让所有交流的人知道我们聊的是在同一个领域边界内的事情，合起来就是用来封装通用语言和领域对象，提供上下文环境，保证在领域之内的一些术语、业务相关对象等（通用语言）有一个确切的含义，没有二义性。这个边界定义了模型的适用范围，使团队所有成员能够明确地知道什么应该在模型中实现，什么不应该在模型中实现。

> **上限界上下文概念    **
>
> 都说中文这门语言非常丰富，在不同的时空和背景下，同样的一句话会有不同的涵义。有一个例子你应该听说过。在一个明媚的早晨，孩子起床问妈妈：“今天应该穿几件衣服呀？”妈妈回答：“能穿多少就穿多少！”
>
> **那到底是穿多还是穿少呢？**
>
> 如果没有具体的语义环境，还真不太好理解。但是，如果你已经知道了这句话的语义环境，比如是寒冬腊月或者是炎炎夏日，那理解这句话的涵义就会很容易了。所以语言离不开它的语义环境。而业务的通用语言就有它的业务边界，我们不大可能用一个简单的术语没有歧义地去描述一个复杂的业务领域。限界上下文就是用来细分领域，从而定义通用语言所在的边界。现在我们用一个保险领域的例子来说明下术语的边界。
>
> 保险业务领域有投保单、核保、财务、回访、保全等保险术语，它们分别应用于保险的不同业务流程。
>
> 1. 客户投保时，业务人员记录投保信息，系统对应有投保单实体对象。
> 2. 缴费完成后，业务人员将投保单转为保单，系统对应有保单实体对象，保单实体与投保单实体关联。
> 3. 如客户需要修改保单信息，保单变为批单，有保全系统对应有批单实体对象，批单实体与保单实体关联。
> 4. 如果客户发生理赔，生成赔案，系统对应有报案实体对象，报案实体对象与保单或者批单实体关联。投保单、保单、批单、赔案等，这些术语虽然都跟保单有关，但不能将保单这个术语作用在保险全业务领域。因为术语有它的边界，超出了边界理解上就会出现问题。
> 5. 正如电商领域的商品一样，商品在不同的阶段有不同的术语，在销售阶段是商品，而在运输阶段则变成了货物。同样的一个东西，由于业务领域的不同，赋予了这些术语不同的涵义和职责边界，这个边界就可能会成为未来微服务设计的边界。看到这，我想你应该非常清楚了，领域边界就是通过限界上下文来定义的。
>
> **限界上下文在微服务设计中作用以及意义是什么**
>
> 接下来，我们对这个概念做进一步的延伸。看看限界上下文和微服务具体存在怎样的关系。我想你买过保险吧，或者听过吧。保险承保的流程包含了投保、缴费、出单等几个主要流程。如果出险了还会有报案、查勘、定损、理算等理赔流程。
>
> 首先，领域可以拆分为多个子领域。一个领域相当于一个问题域，领域拆分为子域的过程就是大问题拆分为小问题的过程。在这个图里面保险领域被拆分为：投保、支付、保单管理和理赔四个子域。
>
> 子域还可根据需要进一步拆分为子子域，比如，支付子域可继续拆分为收款和付款子子域。拆到一定程度后，有些子子域的领域边界就可能变成限界上下文的边界了。子域可能会包含多个限界上下文，如理赔子域就包括报案、查勘和定损等多个限界上下文（限界上下文与理赔的子子域领域边界重合）。也有可能子域本身的边界就是限界上下文边界，如投保子域。
>
> 每个领域模型都有它对应的限界上下文，团队在限界上下文内用通用语言交流。领域内所有限界上下文的领域模型构成整个领域的领域模型。理论上限界上下文就是微服务的边界。我们将限界上下文内的领域模型映射到微服务，就完成了从问题域到软件的解决方案。
>
> 可以说，限界上下文是微服务设计和拆分的主要依据。在领域模型中，如果不考虑技术异构、团队沟通等其它外部因素，一个限界上下文理论上就可以设计为一个微服务。不过，这里还是要提示一下：除了理论，微服务的拆分还是有很多限制因素的，在设计中不宜过度拆分。



### 集成

#### 理想的集成技术

- 避免破坏性修改
- 保证API的技术无关性：保证微服务之间的通信方式的技术无关性，意味着不应该选择那些对于微服务的具体实现技术有限制的集成方式。
- 使你的服务易于消费方使用
- 隐藏内部实现细节：所有倾向于暴露内部实现细节的技术都不应该被采用。

#### 共享数据库

和前面文件共享传输的方案比起来，这种方案有一个相对的优势，就是可以保证数据的一致性。在原来的方案中，如果文件要传输给多个应用的话，我们是没办法保证所有应用的数据是同步而且一致的。有可能有的快有的慢。而在这里，所有的数据都是统一存储在公共的数据库里，也就不存在这样的问题了。对于任何一个系统产生的数据或者变化，另外一个系统也就马上可以看到。

当然，这种方案也有它不足的地方。首先一个问题就是对于多个应用来说，这个共享数据库需要能够适应他们所有的场景。不同的应用考量的点是不一样的，要能适应所有的需求对于数据库这一部分就显得尤其的困难。还有一个就是性能方面的问题，不同的应用可能会同时访问相同的数据导致数据访问冲突，因此也会带来如死锁等问题。

#### 同步与异步

同步通信：发起一个RPC调用之后，调用方会阻塞自己并且等待整个操作的完成。

异步通信：发起一个调用之后，调用方不等待操作完成就可以返回，甚至可能不需要关心这个操作有没有完成。

同步通信听起来合理，因为可以知道事情到底成功与否。异步通信对于运行时间比较长的任务来说比较有用，否则就需要在客户端和服务器之间开启一个长连接，而这是非常不实际的。当你需要低延迟的时候，通常会使用异步通信，否则会由于阻塞而降低运行的速度。

这两种不同的通信模式有着各自的协作风格，**即请求/响应或者基于事件**。**对于请求/响应来说，客户端发起一个请求，然后等待响应。这种模式能够与同步通信模式很好地匹配**，但异步通信也可以使用这种模式。我可以发起一个请求，然后注册一个回调，当服务端操作结束之后，会调用该回调。

**对于使用基于事件的协作方式来说，情况会颠倒过来。客户端不是发起请求，而是发布一个事件，然后期待其他的协作者接收到该消息，并且知道该怎么做。**我们从来不会告知任何人去做任何事情。**基于事件的系统天生就是异步的。**整个系统都很聪明，也就是说，业务逻辑并非集中存在于某个核心大脑，而是平均地分布在不同的协作者中。基于事件的协作方式耦合性很低。**客户端发布一个事件，但并不需要知道谁或者什么会对此做出响应，这也意味着，你可以在不影响客户端的情况下对该事件添加新的订阅者。**

哪些因素会影响对这两种风格的选择呢？一个重要的因素是这种风格能否很好地解决复杂问题，比如如何处理跨服务边界的流程，而且这种流程有可能会运行很长时间。

> 针对请求/响应方式，可以考虑两种技术：RPC（Remote Procedure Call，远程过程调用）和REST（REpresentational State Transfer，表述性状态转移）。

#### 远程过程调用（Remote Procedure Call）

一个节点通过网络请求另一个节点的服务

[什么是RPC？ - 简书 (jianshu.com)](https://www.jianshu.com/p/7d6853140e13)

- 本地过程调用：如果需要将本地student对象的age+1，可以实现一个addAge()方法，将student对象传入，对年龄进行更新之后返回即可，本地方法调用的函数体通过函数指针来指定。

- 远程过程调用：上述操作的过程中，如果addAge()这个方法在服务端，执行函数的函数体在远程机器上，如何告诉机器需要调用这个方法呢？
  1. 首先客户端需要告诉服务器，需要调用的函数，这里函数和进程ID存在一个映射，客户端远程调用时，需要查一下函数，找到对应的ID，然后执行函数的代码。
  2. 客户端需要把本地参数传给远程函数，本地调用的过程中，直接压栈即可，但是在远程调用过程中不再同一个内存里，无法直接传递函数的参数，因此需要客户端把参数转换成字节流，传给服务端，然后服务端将字节流转换成自身能读取的格式，是一个序列化和反序列化的过程。
  3. 数据准备好了之后，如何进行传输？网络传输层需要把调用的ID和序列化后的参数传给服务端，然后把计算好的结果序列化传给客户端，因此TCP层即可完成上述过程，gRPC中采用的是HTTP2协议。

**由于HTTP在应用层中完成，整个通信的代价较高，RPC直接基于TCP进行远程调用，数据传输在传输层TCP层完成，更适合对效率要求比较高的场景，RPC主要依赖于客户端和服务端之间建立Socket链接进行，底层实现比REST更复杂。**

##### RPC的三个过程

1. 通讯协议 == 比如：你需要找人在国外干活，那么你可以直接飞过去或者打电话或者通过互联网的形式，去找人，这个找人的过程就是通讯协议 
2. 寻址 == 既然要找人干活，肯定要知道地址在哪，飞过去需要找到详细地址，打电话需要知道电话号码，互联网需要知道IP是多少
3. 数据序列化 == 就是说，语言需要互通，才能够让别人干活，之间需要一个大家都懂的语言去交流



##### 常用的几种RPC框架

一类是跟某种特定语言平台绑定的，另一类是与语言无关即跨语言平台的。

跟语言平台绑定的开源 RPC 框架主要有下面几种。

- Dubbo：国内最早开源的 RPC 框架，由阿里巴巴公司开发并于 2011 年末对外开源，仅支持 Java 语言。
- Motan：微博内部使用的 RPC 框架，于 2016 年对外开源，仅支持 Java 语言。
- Tars：腾讯内部使用的 RPC 框架，于 2017 年对外开源，仅支持 C++ 语言。
- Spring Cloud：国外 Pivotal 公司 2014 年对外开源的 RPC 框架，仅支持 Java 语言

而跨语言平台的开源 RPC 框架主要有以下几种。

- gRPC：Google 于 2015 年对外开源的跨语言 RPC 框架，支持多种语言。
- Thrift：最初是由 Facebook 开发的内部系统跨语言的 RPC 框架，2007 年贡献给了 Apache 基金，成为 Apache 开源项目之一，支持多种语言。

如果你的业务场景仅仅局限于一种语言的话，可以选择跟语言绑定的 RPC 框架中的一种;

如果涉及多个语言平台之间的相互调用，就应该选择跨语言平台的 RPC 框架。





#### REST











































